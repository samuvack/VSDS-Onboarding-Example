<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Publishing a protected LDES | Onboarding tutorial</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="Publishing a protected LDES" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Publishing and Accessing a Protected LDES This tutorial will show you how to protect a LDES in order to prevent unauthorized access to a proprietary (or a public) data collection. It will also show how to expose the available LDES Server API as well as add and expose some metadata (using DCAT). In addition it will show you how to access such a protected LDES. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. I’ll Protect You From the Hooded Claw The LDES Server allows you to ingest a data collection and offers one or more views which allows replicating the data collection in whole or a part of it. However, not all data collection can be made publicly available. You need to protect those data collection in some way to prevent unauthorized access. What you will typically do is configure some security system which expects a Data Client to identify itself (authentication) after which the security system verifies it the Data Client has access to the requested data (authorization). The LDES Server does not include such a security system because there are various ways for doing authentication anad authorization and no one-size fits all. You may want to protect the data simply with an API key (secret key shared with a Data Client), using OAuth2 (authorization only) and/or OpenID (based on OAuth2 adding authentication), etc. There are many open-source and commercial implementations available for these and other protocols, so we decided to not include this aspect into the LDES Server. This keeps the server lean and simple for serving open data collections. But, even if you have a open data collection you may want to add a security layer to it to keep usage statistics per Data Client, e.g. to enforce fair usage policies, etc. So, we will look into how you can protect a LDES using a simple API key per Data Client and how the Data Client can access such a LDES. This technique may also apply to a commercial data collection: as a Data Publisher you may also want to offer a part of your data to the public for publicity and marketing reasons but of course you will want to track its usage. We will show how you can protect a LDES and what changes are needed to retrieve such a LDES. We will use existing tutorials to kickstart our setup. To create and feed our LDES we can use the advanced conversion setup and to retrieve it we can use the minimal client. Later we will add a reverse proxy to shield the LDES Server from the outside and configure things in such a way that we have controlled access to both LDES Server administration and LDES replication &amp; synchronization. Obviously we will have to make changes on both the Data Publisher and the Data Client side. But first, let us setup the system without access limitation first to ensure everything works fine. As usual, we start by creating a docker compose file containing the services that we need. At the Data Publisher side we need a database for the LDES Server (ldes-mongodb), the LDES Server itself (ldes-server) and a workbench to feed the LDES Server (server-workbench). We can basically copy/paste the services from the advanced conversion docker compose file: ldes-mongodb: container_name: protected-setup_ldes-mongodb image: mongo:latest ports: - 27017:27017 networks: - protected-setup ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro ports: - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} server-workbench: container_name: protected-setup_server-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version volumes: - ./server-workbench/config:/ldio/config:ro - ./server-workbench/application.yml:/ldio/application.yml:ro ports: - 9004:80 networks: - protected-setup profiles: - delay-started Notes: for clarity we renamed the network as well as the container names we also renamed the workbench in order to stress that this is the workbench which feeds the LDES Server we moved the configuration files to organize the setup a bit we added an environment variable LDES_SERVER_HOST_NAME to allow changing the ldes-server.host-name in the server configuration easier At the Data Client side we only need a workbench (client-workbench) which we can borrow from the minimal client docker compose file: client-workbench: container_name: protected-setup_client-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version environment: - LDES_SERVER_URL=${LDES_SERVER_URL:-http://localhost:9003/ldes/occupancy/by-page} - SINK_URL=${SINK_URL} - MAX_REQUESTS_PER_MINUTE=${MAX_REQUESTS_PER_MINUTE:-50} volumes: - ./client-workbench/application.yml:/ldio/application.yml:ro network_mode: &quot;host&quot; profiles: - delay-started Notes we renamed the container and the service we moved the configuration files we added a profile to prevent the client workbench to start ahead of time Note that the client workbench uses the network of the host which is completely disconnected from the internal docker network used by the LDES Server and its database and workbench. The LDES Client component therefore needs to use the host name (localhost) and exposed server port (9003) to access the LDES. That is why we have configured both the LDES_SERVER_HOST_NAME and the LDES_SERVER_URL to start with http://localhost:9003/. What we have now is illustrated in the following system container diagram: Fig. 1 - Unprotected setup At this point we can run all the systems and verify that we receive the LDES members in the sink. Please open https://webhook.site/ in a browser windows and copy your unique URL. Copy the .env file to user.env and fill in your unique URL as the sink URL. Now start all systems using (in a bash shell): clear # start and wait for the server and database systems docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # define the LDES and the view curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once you have verified that the members appear in the sink you can shutdown the systems and remove the private network for now using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down It’s a Well Kept Secret Now that we have a unprotected but working setup we can make the necessary changes to enforce security. We will need to do a few things: add a reverse proxy that will accept the LDES requests on the server’s behalf, check authentication &amp; authorization and forward the request or return an access error not expose the LDES Server outside of the internal docker network so that the only way to access it is through the reverse proxy change the Data Client (and Data Publisher) configuration to retrieve the LDES through the reverse proxy The following illustration shows the setup after adding such a reverse proxy: Fig. 2 - Protected setup The first thing we need to asks ourselves is which endpoints we need to protect but before we can answer that question we need to know what endpoints are available. By default, the LDES Server does not make that immediately apparant but by exposing the so called Swagger UI we can make the available API visible. If we add the following to the server configuration and launch it, we should see it: springdoc: swagger-ui: path: /admin/doc/v1/swagger urlsPrimaryName: base Note that we expose our swagger UI on the ‘admin’ API so we can protect it together with the rest of the admin API later. The path allows us to define the endpoint where the API information is visualized and the urlsPrimaryName allows us to choose which collection of APIs are displayed by default when we browse to the swagger UI endpoint. Now, in order to see it, we need to launch the server again: clear docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once started point your browser to http://localhost:9003/ldes/admin/doc/v1/swagger. You will be redirected to http://localhost:9003/ldes/admin/doc/v1/swagger-ui/index.html and in the top right corner you should see the base API collection selected and the base API displayed in the main window. When we look at this base API, we see that there is one endpoint for the ingest that expects a POST to an endpoint. Obviously we do not want anybody else than the server workbench to push members to our ingest endpoint so we need to disallow this through the reverse proxy. We can do that by disallowing POST requests through the reverse proxy but we need to ensure that we can still seed the LDES definitions, which also use POST requests towards the administrative API. Next we see that the LDES Server exposes an endpoint to retrieve metadata at the root / as well as the various data collections at /{collection-name} and their respective views at /{collection-name}/{view-name}, all using GET requests. Most likely we want the metadata to be publicly accessible so that our available data collections can be discovered. In other words, we want metadata crawlers to be able to retrieve the metadata (typically DCAT information) in an unsecured way so that we get some exposure for our data collections. Now, as for the collections and views themselves, we can setup the accessibility as required by our use cases. For this tutorial we will assume that only a few clients can access our LDES and view so we will protect them with an API key. In fact, we will assign one API key per client so we can distinguish them for statistical reasons (e.g. to enforce a fair use policy). Now, if we switch to the admin API (select admin in the top right dropdown) we see a lot more available endpoints for managing the LDES Server. Obviously, we want to protect the whole admin API (including the swagger UI) so that only we are allowed to manage it. We will do this by protecting it with yet another API key. Note that an API key is not a very secure way of protecting an API. If somebody gets a hold of it, it can be misused. Therefore you should keep it a secret and use HTTPS instead of HTTP communication to prevent somebody sniffing the network and gaining access to the API key. Currently we do not expose any metadata for our LDES. Without going into details of DCAT, we will simply add the metadata (catalog, LDES metadata and view metadata) to our LDES Server by means of the admin API. We have kept the DCAT itself to the bare minimum as that is beyond the scope of the tutorial. It will be sufficient for our purpose. To try this please run: # upload LDES &amp; view definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; Now you can get the full DCAT if you request the root http://localhost:9003/ldes. It is a mix of the metadata definitions which we uploaded and server generated data, resulting in something like this: @prefix by-page: &lt;http://localhost:9003/ldes/occupancy/by-page/&gt; . @prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt; . @prefix ldes: &lt;http://localhost:9003/ldes/&gt; . @prefix occupancy: &lt;http://localhost:9003/ldes/occupancy/&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . @prefix tree: &lt;https://w3id.org/tree/&gt; . ldes:occupancy rdf:type dcat:Dataset ; terms:conformsTo tree:specification , &lt;https://w3id.org/ldes/specification&gt; ; terms:description &quot;LDES containing the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) as LDES&quot;@en . &lt;https://w3id.org/ldes/specification&gt; rdf:type terms:Standard . occupancy:by-page rdf:type rdfs:Resource . &lt;http://localhost:9003/ldes&gt; rdf:type dcat:Catalog ; terms:description &quot;Offers an overview of the dataset(s) and data service(s) needed for the tutorial &#39;Publishing And Accessing a Protected LDES&#39;.&quot;@en ; terms:identifier &quot;c403cbbd-9e4d-47a2-8bb5-41a7642701ba&quot;^^rdfs:Literal ; terms:title &quot;Catalog for Publishing And Accessing a Protected LDES&quot;@en ; dcat:dataset ldes:occupancy ; dcat:service by-page:description . by-page:description rdf:type dcat:DataService ; terms:description &quot;Paged view for the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy/by-page&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) by page&quot;@en ; dcat:endpointDescription &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; ; dcat:endpointURL occupancy:by-page ; dcat:servesDataset ldes:occupancy . tree:specification rdf:type terms:Standard . &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; rdf:type rdfs:Resource . As said before, we want this metadata to be publicly available, while limiting access to the admin API only to ourselves and the LDES &amp; the view to a couple of well-known clients, all by means of a unique API key. You can create these keys using one of the free online GUID generators (e.g. https://www.uuidgenerator.net/guid) or a password generator (e.g. https://www.avast.com/random-password-generator), etc. Add a Reverse Proxy First we need to add the reverse proxy service to the docker compose file: reverse-proxy: image: nginx:stable container_name: protected-setup_reverse-proxy ports: - 9005:8080 volumes: - ./reverse-proxy/protect-ldes-server.conf:/etc/nginx/conf.d/protect-ldes-server.conf:ro depends_on: - ldes-server networks: - protected-setup Here we chose a well-known freely available component that we can setup as a reverse proxy. There are many options out there open-source and commercial. The configuration is highly dependent on the component that you use but the principles are mostly the same: you allow or disallow access to some URL for some HTTP verbs (GET, HEAD, POST, etc) based on some conditions. We’ll be using these three API keys for demonstration purposes: API key Purpose admin-secret admin client-one-secret client 1 client-two-secret client 2 This translates to a mapping for our reverse proxy. Next we define an API key validation location, meaning that for the URLs we need to protect we use this internal virtual URL for verifying the presence and validity of the given API key. Finally we add our access rules. As previously said we need to: allow access to metadata to the public allow access to admin API (including the swagger API) only to administrators allow access to the LDES, the view and all view nodes for registered clients only do not allow access to the ingest endpoint (no POST to LDES endpoint allowed from outside) For this particular reverse proxy we end up with this configuration and can start the reverse proxy to test if the rules allow or disallow access correctly: docker compose up reverse-proxy -d We have setup the reverse proxy to remap the LDES Server endpoints (all based at /ldes) a bit. The reverse proxy serves: the metadata at / the admin API at /admin the LDES, the view and its nodes at /feed If we do not pass an API key we can retrieve only the metadata and not the LDES, the view, the admin API and the swagger UI: clear curl -I http://localhost:9005/ curl -I http://localhost:9005/feed/occupancy curl -I http://localhost:9005/feed/occupancy/by-page curl -I http://localhost:9005/admin/api/v1/eventstreams Public access is only allowed (HTTP 200) for the first call, all other calls are unauthenticated (HTTP 401). Note that we pass -I in order to only retrieve the headers, not the actual content. If we pass a client API key we can retrieve the metadata, the LDES and the view but we cannot use the admin API: clear curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/admin/api/v1/eventstreams All but the last call should succeed (HTTP 200) while the last one is forbidden (HTTP 403) because we are authenticated but not authorized to use the admin API. Note that we need to pass the API key using the header x-api-key: &lt;well-known-key&gt;. Finally, if we pass the admin API key all calls should be possible: clear curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/admin/api/v1/eventstreams Now all calls succeed. Great! We need to verify one more rule: nobody (not even an administrator!) should we able to send data to the ingest endpoint of the LDES server: clear curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: client-one-secret&quot; curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: admin-secret&quot; All calls should fail with a forbidden (HTTP 403). Note that it would be better to return method not allowed (HTTP 405) but that seems to be a challenge in this specific reverse proxy configuration. One final thing to test is if we can POST to the admin endpoint, e.g. to define a LDES or add metadata. curl -X POST -d &quot;@./ldes-server/metadata/catalog.ttl&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -H &quot;x-api-key: admin-secret&quot; Should return an error similar to Resource of type: dcat-catalog with id: c403cbbd-9e4d-47a2-8bb5-41a7642701ba already exists. because we have already defined the catalog. But, this is great news because this means the reverse proxy let the request go through and the LDES Server returns an error response. Do Not Expose the LDES Server Now that everything is working great we can simply remove (or comment out) the port mapping of the server in the docker compose file as we do not need and do not want any direct access to it: ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro # ports: # - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} Access the LDES Server Through the Reverse Proxy Once the LDES Server is not directly accessible anymore, we need to define some environment variables to use the reverse proxy instead: LDES_SERVER_HOST_NAME=http://localhost:9005/feed LDES_SERVER_URL=http://localhost:9005/feed/occupancy and we need to pass our user.env file to all our docker compose commands. Of course, we should not forget the most important part: configure the LDES Client to pass a API key when requesting the LDES nodes. In the client workbench we need to change the LDES CLient component configuration to include this API key: input: name: Ldio:LdesClient config: urls: - ${LDES_SERVER_URL} sourceFormat: application/n-quads auth: type: API_KEY api-key-header: x-api-key api-key: client-two-secret Show time! But first bring down all systems so we can start with a clean slate: docker compose down Putting It All Together To launch all the systems and configure it all you can run the following: clear # start and wait for the server and database systems docker compose --env-file user.env up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # upload LDES &amp; view definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose --env-file user.env up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done It all goes well (and it should!) you will see the LDES members appear in the sink. It’s Been a Long Day We have shown you how to enable the swagger UI, how to provide metadata for your LDES views and, of course, how to access a protected LDES. In addition we have shown you how you can protect a LDES using a API key but if you require a stronger way of securing access have a look at other authentication and authorization mechanisms. The documentation explains how to configure the LDES client in case you need to access an OAuth2/OpenID protected LDES. Now that you have verified that the members appear in the sink you can shutdown the systems and remove the private network using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down" /> <meta property="og:description" content="Publishing and Accessing a Protected LDES This tutorial will show you how to protect a LDES in order to prevent unauthorized access to a proprietary (or a public) data collection. It will also show how to expose the available LDES Server API as well as add and expose some metadata (using DCAT). In addition it will show you how to access such a protected LDES. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. I’ll Protect You From the Hooded Claw The LDES Server allows you to ingest a data collection and offers one or more views which allows replicating the data collection in whole or a part of it. However, not all data collection can be made publicly available. You need to protect those data collection in some way to prevent unauthorized access. What you will typically do is configure some security system which expects a Data Client to identify itself (authentication) after which the security system verifies it the Data Client has access to the requested data (authorization). The LDES Server does not include such a security system because there are various ways for doing authentication anad authorization and no one-size fits all. You may want to protect the data simply with an API key (secret key shared with a Data Client), using OAuth2 (authorization only) and/or OpenID (based on OAuth2 adding authentication), etc. There are many open-source and commercial implementations available for these and other protocols, so we decided to not include this aspect into the LDES Server. This keeps the server lean and simple for serving open data collections. But, even if you have a open data collection you may want to add a security layer to it to keep usage statistics per Data Client, e.g. to enforce fair usage policies, etc. So, we will look into how you can protect a LDES using a simple API key per Data Client and how the Data Client can access such a LDES. This technique may also apply to a commercial data collection: as a Data Publisher you may also want to offer a part of your data to the public for publicity and marketing reasons but of course you will want to track its usage. We will show how you can protect a LDES and what changes are needed to retrieve such a LDES. We will use existing tutorials to kickstart our setup. To create and feed our LDES we can use the advanced conversion setup and to retrieve it we can use the minimal client. Later we will add a reverse proxy to shield the LDES Server from the outside and configure things in such a way that we have controlled access to both LDES Server administration and LDES replication &amp; synchronization. Obviously we will have to make changes on both the Data Publisher and the Data Client side. But first, let us setup the system without access limitation first to ensure everything works fine. As usual, we start by creating a docker compose file containing the services that we need. At the Data Publisher side we need a database for the LDES Server (ldes-mongodb), the LDES Server itself (ldes-server) and a workbench to feed the LDES Server (server-workbench). We can basically copy/paste the services from the advanced conversion docker compose file: ldes-mongodb: container_name: protected-setup_ldes-mongodb image: mongo:latest ports: - 27017:27017 networks: - protected-setup ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro ports: - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} server-workbench: container_name: protected-setup_server-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version volumes: - ./server-workbench/config:/ldio/config:ro - ./server-workbench/application.yml:/ldio/application.yml:ro ports: - 9004:80 networks: - protected-setup profiles: - delay-started Notes: for clarity we renamed the network as well as the container names we also renamed the workbench in order to stress that this is the workbench which feeds the LDES Server we moved the configuration files to organize the setup a bit we added an environment variable LDES_SERVER_HOST_NAME to allow changing the ldes-server.host-name in the server configuration easier At the Data Client side we only need a workbench (client-workbench) which we can borrow from the minimal client docker compose file: client-workbench: container_name: protected-setup_client-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version environment: - LDES_SERVER_URL=${LDES_SERVER_URL:-http://localhost:9003/ldes/occupancy/by-page} - SINK_URL=${SINK_URL} - MAX_REQUESTS_PER_MINUTE=${MAX_REQUESTS_PER_MINUTE:-50} volumes: - ./client-workbench/application.yml:/ldio/application.yml:ro network_mode: &quot;host&quot; profiles: - delay-started Notes we renamed the container and the service we moved the configuration files we added a profile to prevent the client workbench to start ahead of time Note that the client workbench uses the network of the host which is completely disconnected from the internal docker network used by the LDES Server and its database and workbench. The LDES Client component therefore needs to use the host name (localhost) and exposed server port (9003) to access the LDES. That is why we have configured both the LDES_SERVER_HOST_NAME and the LDES_SERVER_URL to start with http://localhost:9003/. What we have now is illustrated in the following system container diagram: Fig. 1 - Unprotected setup At this point we can run all the systems and verify that we receive the LDES members in the sink. Please open https://webhook.site/ in a browser windows and copy your unique URL. Copy the .env file to user.env and fill in your unique URL as the sink URL. Now start all systems using (in a bash shell): clear # start and wait for the server and database systems docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # define the LDES and the view curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once you have verified that the members appear in the sink you can shutdown the systems and remove the private network for now using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down It’s a Well Kept Secret Now that we have a unprotected but working setup we can make the necessary changes to enforce security. We will need to do a few things: add a reverse proxy that will accept the LDES requests on the server’s behalf, check authentication &amp; authorization and forward the request or return an access error not expose the LDES Server outside of the internal docker network so that the only way to access it is through the reverse proxy change the Data Client (and Data Publisher) configuration to retrieve the LDES through the reverse proxy The following illustration shows the setup after adding such a reverse proxy: Fig. 2 - Protected setup The first thing we need to asks ourselves is which endpoints we need to protect but before we can answer that question we need to know what endpoints are available. By default, the LDES Server does not make that immediately apparant but by exposing the so called Swagger UI we can make the available API visible. If we add the following to the server configuration and launch it, we should see it: springdoc: swagger-ui: path: /admin/doc/v1/swagger urlsPrimaryName: base Note that we expose our swagger UI on the ‘admin’ API so we can protect it together with the rest of the admin API later. The path allows us to define the endpoint where the API information is visualized and the urlsPrimaryName allows us to choose which collection of APIs are displayed by default when we browse to the swagger UI endpoint. Now, in order to see it, we need to launch the server again: clear docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once started point your browser to http://localhost:9003/ldes/admin/doc/v1/swagger. You will be redirected to http://localhost:9003/ldes/admin/doc/v1/swagger-ui/index.html and in the top right corner you should see the base API collection selected and the base API displayed in the main window. When we look at this base API, we see that there is one endpoint for the ingest that expects a POST to an endpoint. Obviously we do not want anybody else than the server workbench to push members to our ingest endpoint so we need to disallow this through the reverse proxy. We can do that by disallowing POST requests through the reverse proxy but we need to ensure that we can still seed the LDES definitions, which also use POST requests towards the administrative API. Next we see that the LDES Server exposes an endpoint to retrieve metadata at the root / as well as the various data collections at /{collection-name} and their respective views at /{collection-name}/{view-name}, all using GET requests. Most likely we want the metadata to be publicly accessible so that our available data collections can be discovered. In other words, we want metadata crawlers to be able to retrieve the metadata (typically DCAT information) in an unsecured way so that we get some exposure for our data collections. Now, as for the collections and views themselves, we can setup the accessibility as required by our use cases. For this tutorial we will assume that only a few clients can access our LDES and view so we will protect them with an API key. In fact, we will assign one API key per client so we can distinguish them for statistical reasons (e.g. to enforce a fair use policy). Now, if we switch to the admin API (select admin in the top right dropdown) we see a lot more available endpoints for managing the LDES Server. Obviously, we want to protect the whole admin API (including the swagger UI) so that only we are allowed to manage it. We will do this by protecting it with yet another API key. Note that an API key is not a very secure way of protecting an API. If somebody gets a hold of it, it can be misused. Therefore you should keep it a secret and use HTTPS instead of HTTP communication to prevent somebody sniffing the network and gaining access to the API key. Currently we do not expose any metadata for our LDES. Without going into details of DCAT, we will simply add the metadata (catalog, LDES metadata and view metadata) to our LDES Server by means of the admin API. We have kept the DCAT itself to the bare minimum as that is beyond the scope of the tutorial. It will be sufficient for our purpose. To try this please run: # upload LDES &amp; view definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; Now you can get the full DCAT if you request the root http://localhost:9003/ldes. It is a mix of the metadata definitions which we uploaded and server generated data, resulting in something like this: @prefix by-page: &lt;http://localhost:9003/ldes/occupancy/by-page/&gt; . @prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt; . @prefix ldes: &lt;http://localhost:9003/ldes/&gt; . @prefix occupancy: &lt;http://localhost:9003/ldes/occupancy/&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . @prefix tree: &lt;https://w3id.org/tree/&gt; . ldes:occupancy rdf:type dcat:Dataset ; terms:conformsTo tree:specification , &lt;https://w3id.org/ldes/specification&gt; ; terms:description &quot;LDES containing the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) as LDES&quot;@en . &lt;https://w3id.org/ldes/specification&gt; rdf:type terms:Standard . occupancy:by-page rdf:type rdfs:Resource . &lt;http://localhost:9003/ldes&gt; rdf:type dcat:Catalog ; terms:description &quot;Offers an overview of the dataset(s) and data service(s) needed for the tutorial &#39;Publishing And Accessing a Protected LDES&#39;.&quot;@en ; terms:identifier &quot;c403cbbd-9e4d-47a2-8bb5-41a7642701ba&quot;^^rdfs:Literal ; terms:title &quot;Catalog for Publishing And Accessing a Protected LDES&quot;@en ; dcat:dataset ldes:occupancy ; dcat:service by-page:description . by-page:description rdf:type dcat:DataService ; terms:description &quot;Paged view for the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy/by-page&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) by page&quot;@en ; dcat:endpointDescription &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; ; dcat:endpointURL occupancy:by-page ; dcat:servesDataset ldes:occupancy . tree:specification rdf:type terms:Standard . &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; rdf:type rdfs:Resource . As said before, we want this metadata to be publicly available, while limiting access to the admin API only to ourselves and the LDES &amp; the view to a couple of well-known clients, all by means of a unique API key. You can create these keys using one of the free online GUID generators (e.g. https://www.uuidgenerator.net/guid) or a password generator (e.g. https://www.avast.com/random-password-generator), etc. Add a Reverse Proxy First we need to add the reverse proxy service to the docker compose file: reverse-proxy: image: nginx:stable container_name: protected-setup_reverse-proxy ports: - 9005:8080 volumes: - ./reverse-proxy/protect-ldes-server.conf:/etc/nginx/conf.d/protect-ldes-server.conf:ro depends_on: - ldes-server networks: - protected-setup Here we chose a well-known freely available component that we can setup as a reverse proxy. There are many options out there open-source and commercial. The configuration is highly dependent on the component that you use but the principles are mostly the same: you allow or disallow access to some URL for some HTTP verbs (GET, HEAD, POST, etc) based on some conditions. We’ll be using these three API keys for demonstration purposes: API key Purpose admin-secret admin client-one-secret client 1 client-two-secret client 2 This translates to a mapping for our reverse proxy. Next we define an API key validation location, meaning that for the URLs we need to protect we use this internal virtual URL for verifying the presence and validity of the given API key. Finally we add our access rules. As previously said we need to: allow access to metadata to the public allow access to admin API (including the swagger API) only to administrators allow access to the LDES, the view and all view nodes for registered clients only do not allow access to the ingest endpoint (no POST to LDES endpoint allowed from outside) For this particular reverse proxy we end up with this configuration and can start the reverse proxy to test if the rules allow or disallow access correctly: docker compose up reverse-proxy -d We have setup the reverse proxy to remap the LDES Server endpoints (all based at /ldes) a bit. The reverse proxy serves: the metadata at / the admin API at /admin the LDES, the view and its nodes at /feed If we do not pass an API key we can retrieve only the metadata and not the LDES, the view, the admin API and the swagger UI: clear curl -I http://localhost:9005/ curl -I http://localhost:9005/feed/occupancy curl -I http://localhost:9005/feed/occupancy/by-page curl -I http://localhost:9005/admin/api/v1/eventstreams Public access is only allowed (HTTP 200) for the first call, all other calls are unauthenticated (HTTP 401). Note that we pass -I in order to only retrieve the headers, not the actual content. If we pass a client API key we can retrieve the metadata, the LDES and the view but we cannot use the admin API: clear curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/admin/api/v1/eventstreams All but the last call should succeed (HTTP 200) while the last one is forbidden (HTTP 403) because we are authenticated but not authorized to use the admin API. Note that we need to pass the API key using the header x-api-key: &lt;well-known-key&gt;. Finally, if we pass the admin API key all calls should be possible: clear curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/admin/api/v1/eventstreams Now all calls succeed. Great! We need to verify one more rule: nobody (not even an administrator!) should we able to send data to the ingest endpoint of the LDES server: clear curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: client-one-secret&quot; curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: admin-secret&quot; All calls should fail with a forbidden (HTTP 403). Note that it would be better to return method not allowed (HTTP 405) but that seems to be a challenge in this specific reverse proxy configuration. One final thing to test is if we can POST to the admin endpoint, e.g. to define a LDES or add metadata. curl -X POST -d &quot;@./ldes-server/metadata/catalog.ttl&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -H &quot;x-api-key: admin-secret&quot; Should return an error similar to Resource of type: dcat-catalog with id: c403cbbd-9e4d-47a2-8bb5-41a7642701ba already exists. because we have already defined the catalog. But, this is great news because this means the reverse proxy let the request go through and the LDES Server returns an error response. Do Not Expose the LDES Server Now that everything is working great we can simply remove (or comment out) the port mapping of the server in the docker compose file as we do not need and do not want any direct access to it: ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro # ports: # - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} Access the LDES Server Through the Reverse Proxy Once the LDES Server is not directly accessible anymore, we need to define some environment variables to use the reverse proxy instead: LDES_SERVER_HOST_NAME=http://localhost:9005/feed LDES_SERVER_URL=http://localhost:9005/feed/occupancy and we need to pass our user.env file to all our docker compose commands. Of course, we should not forget the most important part: configure the LDES Client to pass a API key when requesting the LDES nodes. In the client workbench we need to change the LDES CLient component configuration to include this API key: input: name: Ldio:LdesClient config: urls: - ${LDES_SERVER_URL} sourceFormat: application/n-quads auth: type: API_KEY api-key-header: x-api-key api-key: client-two-secret Show time! But first bring down all systems so we can start with a clean slate: docker compose down Putting It All Together To launch all the systems and configure it all you can run the following: clear # start and wait for the server and database systems docker compose --env-file user.env up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # upload LDES &amp; view definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose --env-file user.env up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done It all goes well (and it should!) you will see the LDES members appear in the sink. It’s Been a Long Day We have shown you how to enable the swagger UI, how to provide metadata for your LDES views and, of course, how to access a protected LDES. In addition we have shown you how you can protect a LDES using a API key but if you require a stronger way of securing access have a look at other authentication and authorization mechanisms. The documentation explains how to configure the LDES client in case you need to access an OAuth2/OpenID protected LDES. Now that you have verified that the members appear in the sink you can shutdown the systems and remove the private network using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down" /> <link rel="canonical" href="http://localhost:4000/publishing/publishing_protected_LDES" /> <meta property="og:url" content="http://localhost:4000/publishing/publishing_protected_LDES" /> <meta property="og:site_name" content="Onboarding tutorial" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-02-19T11:01:58+01:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Publishing a protected LDES" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-19T11:01:58+01:00","datePublished":"2024-02-19T11:01:58+01:00","description":"Publishing and Accessing a Protected LDES This tutorial will show you how to protect a LDES in order to prevent unauthorized access to a proprietary (or a public) data collection. It will also show how to expose the available LDES Server API as well as add and expose some metadata (using DCAT). In addition it will show you how to access such a protected LDES. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. I’ll Protect You From the Hooded Claw The LDES Server allows you to ingest a data collection and offers one or more views which allows replicating the data collection in whole or a part of it. However, not all data collection can be made publicly available. You need to protect those data collection in some way to prevent unauthorized access. What you will typically do is configure some security system which expects a Data Client to identify itself (authentication) after which the security system verifies it the Data Client has access to the requested data (authorization). The LDES Server does not include such a security system because there are various ways for doing authentication anad authorization and no one-size fits all. You may want to protect the data simply with an API key (secret key shared with a Data Client), using OAuth2 (authorization only) and/or OpenID (based on OAuth2 adding authentication), etc. There are many open-source and commercial implementations available for these and other protocols, so we decided to not include this aspect into the LDES Server. This keeps the server lean and simple for serving open data collections. But, even if you have a open data collection you may want to add a security layer to it to keep usage statistics per Data Client, e.g. to enforce fair usage policies, etc. So, we will look into how you can protect a LDES using a simple API key per Data Client and how the Data Client can access such a LDES. This technique may also apply to a commercial data collection: as a Data Publisher you may also want to offer a part of your data to the public for publicity and marketing reasons but of course you will want to track its usage. We will show how you can protect a LDES and what changes are needed to retrieve such a LDES. We will use existing tutorials to kickstart our setup. To create and feed our LDES we can use the advanced conversion setup and to retrieve it we can use the minimal client. Later we will add a reverse proxy to shield the LDES Server from the outside and configure things in such a way that we have controlled access to both LDES Server administration and LDES replication &amp; synchronization. Obviously we will have to make changes on both the Data Publisher and the Data Client side. But first, let us setup the system without access limitation first to ensure everything works fine. As usual, we start by creating a docker compose file containing the services that we need. At the Data Publisher side we need a database for the LDES Server (ldes-mongodb), the LDES Server itself (ldes-server) and a workbench to feed the LDES Server (server-workbench). We can basically copy/paste the services from the advanced conversion docker compose file: ldes-mongodb: container_name: protected-setup_ldes-mongodb image: mongo:latest ports: - 27017:27017 networks: - protected-setup ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro ports: - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} server-workbench: container_name: protected-setup_server-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version volumes: - ./server-workbench/config:/ldio/config:ro - ./server-workbench/application.yml:/ldio/application.yml:ro ports: - 9004:80 networks: - protected-setup profiles: - delay-started Notes: for clarity we renamed the network as well as the container names we also renamed the workbench in order to stress that this is the workbench which feeds the LDES Server we moved the configuration files to organize the setup a bit we added an environment variable LDES_SERVER_HOST_NAME to allow changing the ldes-server.host-name in the server configuration easier At the Data Client side we only need a workbench (client-workbench) which we can borrow from the minimal client docker compose file: client-workbench: container_name: protected-setup_client-workbench image: ldes/ldi-orchestrator:2.0.0-SNAPSHOT # you can safely change this to the latest 1.x.y version environment: - LDES_SERVER_URL=${LDES_SERVER_URL:-http://localhost:9003/ldes/occupancy/by-page} - SINK_URL=${SINK_URL} - MAX_REQUESTS_PER_MINUTE=${MAX_REQUESTS_PER_MINUTE:-50} volumes: - ./client-workbench/application.yml:/ldio/application.yml:ro network_mode: &quot;host&quot; profiles: - delay-started Notes we renamed the container and the service we moved the configuration files we added a profile to prevent the client workbench to start ahead of time Note that the client workbench uses the network of the host which is completely disconnected from the internal docker network used by the LDES Server and its database and workbench. The LDES Client component therefore needs to use the host name (localhost) and exposed server port (9003) to access the LDES. That is why we have configured both the LDES_SERVER_HOST_NAME and the LDES_SERVER_URL to start with http://localhost:9003/. What we have now is illustrated in the following system container diagram: Fig. 1 - Unprotected setup At this point we can run all the systems and verify that we receive the LDES members in the sink. Please open https://webhook.site/ in a browser windows and copy your unique URL. Copy the .env file to user.env and fill in your unique URL as the sink URL. Now start all systems using (in a bash shell): clear # start and wait for the server and database systems docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # define the LDES and the view curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once you have verified that the members appear in the sink you can shutdown the systems and remove the private network for now using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down It’s a Well Kept Secret Now that we have a unprotected but working setup we can make the necessary changes to enforce security. We will need to do a few things: add a reverse proxy that will accept the LDES requests on the server’s behalf, check authentication &amp; authorization and forward the request or return an access error not expose the LDES Server outside of the internal docker network so that the only way to access it is through the reverse proxy change the Data Client (and Data Publisher) configuration to retrieve the LDES through the reverse proxy The following illustration shows the setup after adding such a reverse proxy: Fig. 2 - Protected setup The first thing we need to asks ourselves is which endpoints we need to protect but before we can answer that question we need to know what endpoints are available. By default, the LDES Server does not make that immediately apparant but by exposing the so called Swagger UI we can make the available API visible. If we add the following to the server configuration and launch it, we should see it: springdoc: swagger-ui: path: /admin/doc/v1/swagger urlsPrimaryName: base Note that we expose our swagger UI on the ‘admin’ API so we can protect it together with the rest of the admin API later. The path allows us to define the endpoint where the API information is visualized and the urlsPrimaryName allows us to choose which collection of APIs are displayed by default when we browse to the swagger UI endpoint. Now, in order to see it, we need to launch the server again: clear docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Once started point your browser to http://localhost:9003/ldes/admin/doc/v1/swagger. You will be redirected to http://localhost:9003/ldes/admin/doc/v1/swagger-ui/index.html and in the top right corner you should see the base API collection selected and the base API displayed in the main window. When we look at this base API, we see that there is one endpoint for the ingest that expects a POST to an endpoint. Obviously we do not want anybody else than the server workbench to push members to our ingest endpoint so we need to disallow this through the reverse proxy. We can do that by disallowing POST requests through the reverse proxy but we need to ensure that we can still seed the LDES definitions, which also use POST requests towards the administrative API. Next we see that the LDES Server exposes an endpoint to retrieve metadata at the root / as well as the various data collections at /{collection-name} and their respective views at /{collection-name}/{view-name}, all using GET requests. Most likely we want the metadata to be publicly accessible so that our available data collections can be discovered. In other words, we want metadata crawlers to be able to retrieve the metadata (typically DCAT information) in an unsecured way so that we get some exposure for our data collections. Now, as for the collections and views themselves, we can setup the accessibility as required by our use cases. For this tutorial we will assume that only a few clients can access our LDES and view so we will protect them with an API key. In fact, we will assign one API key per client so we can distinguish them for statistical reasons (e.g. to enforce a fair use policy). Now, if we switch to the admin API (select admin in the top right dropdown) we see a lot more available endpoints for managing the LDES Server. Obviously, we want to protect the whole admin API (including the swagger UI) so that only we are allowed to manage it. We will do this by protecting it with yet another API key. Note that an API key is not a very secure way of protecting an API. If somebody gets a hold of it, it can be misused. Therefore you should keep it a secret and use HTTPS instead of HTTP communication to prevent somebody sniffing the network and gaining access to the API key. Currently we do not expose any metadata for our LDES. Without going into details of DCAT, we will simply add the metadata (catalog, LDES metadata and view metadata) to our LDES Server by means of the admin API. We have kept the DCAT itself to the bare minimum as that is beyond the scope of the tutorial. It will be sufficient for our purpose. To try this please run: # upload LDES &amp; view definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; Now you can get the full DCAT if you request the root http://localhost:9003/ldes. It is a mix of the metadata definitions which we uploaded and server generated data, resulting in something like this: @prefix by-page: &lt;http://localhost:9003/ldes/occupancy/by-page/&gt; . @prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt; . @prefix ldes: &lt;http://localhost:9003/ldes/&gt; . @prefix occupancy: &lt;http://localhost:9003/ldes/occupancy/&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . @prefix tree: &lt;https://w3id.org/tree/&gt; . ldes:occupancy rdf:type dcat:Dataset ; terms:conformsTo tree:specification , &lt;https://w3id.org/ldes/specification&gt; ; terms:description &quot;LDES containing the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) as LDES&quot;@en . &lt;https://w3id.org/ldes/specification&gt; rdf:type terms:Standard . occupancy:by-page rdf:type rdfs:Resource . &lt;http://localhost:9003/ldes&gt; rdf:type dcat:Catalog ; terms:description &quot;Offers an overview of the dataset(s) and data service(s) needed for the tutorial &#39;Publishing And Accessing a Protected LDES&#39;.&quot;@en ; terms:identifier &quot;c403cbbd-9e4d-47a2-8bb5-41a7642701ba&quot;^^rdfs:Literal ; terms:title &quot;Catalog for Publishing And Accessing a Protected LDES&quot;@en ; dcat:dataset ldes:occupancy ; dcat:service by-page:description . by-page:description rdf:type dcat:DataService ; terms:description &quot;Paged view for the occupancy of the various park+rides in Ghent in real time&quot;@en ; terms:identifier &quot;http://localhost:9003/ldes/occupancy/by-page&quot;^^rdfs:Literal ; terms:title &quot;Real time occupancy P+R (Gent) by page&quot;@en ; dcat:endpointDescription &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; ; dcat:endpointURL occupancy:by-page ; dcat:servesDataset ldes:occupancy . tree:specification rdf:type terms:Standard . &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; rdf:type rdfs:Resource . As said before, we want this metadata to be publicly available, while limiting access to the admin API only to ourselves and the LDES &amp; the view to a couple of well-known clients, all by means of a unique API key. You can create these keys using one of the free online GUID generators (e.g. https://www.uuidgenerator.net/guid) or a password generator (e.g. https://www.avast.com/random-password-generator), etc. Add a Reverse Proxy First we need to add the reverse proxy service to the docker compose file: reverse-proxy: image: nginx:stable container_name: protected-setup_reverse-proxy ports: - 9005:8080 volumes: - ./reverse-proxy/protect-ldes-server.conf:/etc/nginx/conf.d/protect-ldes-server.conf:ro depends_on: - ldes-server networks: - protected-setup Here we chose a well-known freely available component that we can setup as a reverse proxy. There are many options out there open-source and commercial. The configuration is highly dependent on the component that you use but the principles are mostly the same: you allow or disallow access to some URL for some HTTP verbs (GET, HEAD, POST, etc) based on some conditions. We’ll be using these three API keys for demonstration purposes: API key Purpose admin-secret admin client-one-secret client 1 client-two-secret client 2 This translates to a mapping for our reverse proxy. Next we define an API key validation location, meaning that for the URLs we need to protect we use this internal virtual URL for verifying the presence and validity of the given API key. Finally we add our access rules. As previously said we need to: allow access to metadata to the public allow access to admin API (including the swagger API) only to administrators allow access to the LDES, the view and all view nodes for registered clients only do not allow access to the ingest endpoint (no POST to LDES endpoint allowed from outside) For this particular reverse proxy we end up with this configuration and can start the reverse proxy to test if the rules allow or disallow access correctly: docker compose up reverse-proxy -d We have setup the reverse proxy to remap the LDES Server endpoints (all based at /ldes) a bit. The reverse proxy serves: the metadata at / the admin API at /admin the LDES, the view and its nodes at /feed If we do not pass an API key we can retrieve only the metadata and not the LDES, the view, the admin API and the swagger UI: clear curl -I http://localhost:9005/ curl -I http://localhost:9005/feed/occupancy curl -I http://localhost:9005/feed/occupancy/by-page curl -I http://localhost:9005/admin/api/v1/eventstreams Public access is only allowed (HTTP 200) for the first call, all other calls are unauthenticated (HTTP 401). Note that we pass -I in order to only retrieve the headers, not the actual content. If we pass a client API key we can retrieve the metadata, the LDES and the view but we cannot use the admin API: clear curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: client-one-secret&quot; http://localhost:9005/admin/api/v1/eventstreams All but the last call should succeed (HTTP 200) while the last one is forbidden (HTTP 403) because we are authenticated but not authorized to use the admin API. Note that we need to pass the API key using the header x-api-key: &lt;well-known-key&gt;. Finally, if we pass the admin API key all calls should be possible: clear curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/ curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/feed/occupancy/by-page curl -I -H &quot;x-api-key: admin-secret&quot; http://localhost:9005/admin/api/v1/eventstreams Now all calls succeed. Great! We need to verify one more rule: nobody (not even an administrator!) should we able to send data to the ingest endpoint of the LDES server: clear curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: client-one-secret&quot; curl -X POST -i -H &quot;content-type: text/turtle&quot; -d @./data/member.ttl http://localhost:9005/feed/occupancy -H &quot;x-api-key: admin-secret&quot; All calls should fail with a forbidden (HTTP 403). Note that it would be better to return method not allowed (HTTP 405) but that seems to be a challenge in this specific reverse proxy configuration. One final thing to test is if we can POST to the admin endpoint, e.g. to define a LDES or add metadata. curl -X POST -d &quot;@./ldes-server/metadata/catalog.ttl&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -H &quot;x-api-key: admin-secret&quot; Should return an error similar to Resource of type: dcat-catalog with id: c403cbbd-9e4d-47a2-8bb5-41a7642701ba already exists. because we have already defined the catalog. But, this is great news because this means the reverse proxy let the request go through and the LDES Server returns an error response. Do Not Expose the LDES Server Now that everything is working great we can simply remove (or comment out) the port mapping of the server in the docker compose file as we do not need and do not want any direct access to it: ldes-server: container_name: protected-setup_ldes-server image: ldes/ldes-server:2.10.0-SNAPSHOT # you can safely change this to the latest 2.x.y version volumes: - ./ldes-server/application.yml:/application.yml:ro # ports: # - 9003:80 networks: - protected-setup depends_on: - ldes-mongodb environment: - MANAGEMENT_TRACING_ENABLED=false # TODO: remove this when pull-based tracing implemented - LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes} Access the LDES Server Through the Reverse Proxy Once the LDES Server is not directly accessible anymore, we need to define some environment variables to use the reverse proxy instead: LDES_SERVER_HOST_NAME=http://localhost:9005/feed LDES_SERVER_URL=http://localhost:9005/feed/occupancy and we need to pass our user.env file to all our docker compose commands. Of course, we should not forget the most important part: configure the LDES Client to pass a API key when requesting the LDES nodes. In the client workbench we need to change the LDES CLient component configuration to include this API key: input: name: Ldio:LdesClient config: urls: - ${LDES_SERVER_URL} sourceFormat: application/n-quads auth: type: API_KEY api-key-header: x-api-key api-key: client-two-secret Show time! But first bring down all systems so we can start with a clean slate: docker compose down Putting It All Together To launch all the systems and configure it all you can run the following: clear # start and wait for the server and database systems docker compose --env-file user.env up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # upload LDES &amp; view definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams&quot; -d &quot;@./ldes-server/definitions/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./ldes-server/definitions/occupancy.by-page.ttl&quot; # upload metadata definitions curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/dcat&quot; -d &quot;@./ldes-server/metadata/catalog.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.ttl&quot; curl -X POST -H &quot;x-api-key: admin-secret&quot; -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9005/admin/api/v1/eventstreams/occupancy/views/by-page/dcat&quot; -d &quot;@./ldes-server/metadata/occupancy.by-page.ttl&quot; # start and wait for the server workbench docker compose --env-file user.env up server-workbench -d while ! docker logs $(docker ps -q -f &quot;name=server-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done # start and wait for the client workbench docker compose --env-file user.env up client-workbench -d while ! docker logs $(docker ps -q -f &quot;name=client-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done It all goes well (and it should!) you will see the LDES members appear in the sink. It’s Been a Long Day We have shown you how to enable the swagger UI, how to provide metadata for your LDES views and, of course, how to access a protected LDES. In addition we have shown you how you can protect a LDES using a API key but if you require a stronger way of securing access have a look at other authentication and authorization mechanisms. The documentation explains how to configure the LDES client in case you need to access an OAuth2/OpenID protected LDES. Now that you have verified that the members appear in the sink you can shutdown the systems and remove the private network using: docker compose rm client-workbench --stop --force --volumes docker compose rm server-workbench --stop --force --volumes docker compose down","headline":"Publishing a protected LDES","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/publishing/publishing_protected_LDES"},"url":"http://localhost:4000/publishing/publishing_protected_LDES"}</script> <!-- End Jekyll SEO tag --> <div class="test-header" data-v-df634f57="" data-v-7a7a37b1=""> <div class="global-header" data-v-df634f57=""><img src="/assets/images/LOGO_Vlaanderen_NIV2.svg" alt="Vlaanderen" data-v-df634f57=""><img class="small-global-header-divider" src="/assets/images/divider_globalheader.svg" alt="divider" data-v-df634f57=""><span class="header-title header-font" data-v-df634f57="">Vlaamse Smart Data Space</span><span class="spacer" data-v-df634f57=""></span> <div id="help-needed" data-v-df634f57=""><span class="header-font" data-v-df634f57="">Hulp nodig</span><a id="help" href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/contact"><img class="question-menu-item" src="/assets/images/question-mark.svg" alt="?" data-v-df634f57=""></a></div> </div> <hr class="divider" data-v-df634f57=""> </div> <div class="navbar navbar-fixed-top"> <div class="navbar-inner"> <div class="container-fluid"> <a href="https://informatievlaanderen.github.io/VSDS-Tech-Docs/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Home</span> </button> </a> <a href="https://github.com/Informatievlaanderen/VSDS-Onboarding-Example"> <button type="button" class="btn btn-navbar custom-border-activated" > <span class="nav-icon-bar">Tutorial</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Linked Data Interactions</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-LDESServer4J/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES server</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/ldio/ldio-inputs/ldio-ldes-client"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES client</span> </button> </a> <a href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/blog"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Blog posts</span> </button> </a> <a href="https://informatievlaanderen.github.io/OSLO-mapping/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">OSLO mapping</span> </button> </a> </div> </div> </div> <style> #help-needed[data-v-df634f57] { display: flex; align-items: center; gap: 5px; background-image: url(https://informatievlaanderen.github.io/OSLO-mapping/assets/images/hulp_nodig.svg); width: 144px; height: 44px; } .custom-border-activated { background-color: rgb(255, 230, 21); } .custom-border { border: 0.3px solid rgb(0, 200, 171); /* Randkleur */ /* Voeg hier eventueel andere stijlelementen toe */ } .navbar-fixed-top .navbar-inner { margin-top:30px; height: 35px; padding: 0; border-top: 1px solid #d4d4d4; z-index: 1000; position: fixed; right:0px; } @media (min-width: 50rem) .navbar-fixed-top { position: relative !important; width: auto !important; height: 100% !important; padding: 0; transition: none; } .global-header[data-v-df634f57] { display: flex; margin-left: 0px; align-items: center; position: fixed; width: 100%; background-color: white; z-index: 100; } .test-header{ margin-bottom: 20px; overflow:hidden; z-index: 100; } element.style { } .small-global-header-divider[data-v-df634f57] { margin: 0 8px 0 4px; } .header-font { color: #333332; font-family: Flanders Art Sans, sans-serif; font-size: 12px; font-style: normal; font-weight: 500; line-height: normal; letter-spacing: 0.5px; text-transform: uppercase; } .spacer { flex-grow: 1; } .divider { border: 1px solid #8f8f8f66; margin: 0; } #help-needed > span[data-v-df634f57] { margin-left: 25px; } /* title of the site */ #header { height: 80px; } #header hgroup { position: absolute; top: 10px; left: 20px; } #header h1 { margin: 0; font-size: 1.75em; font-weight: bold; } #header h2 { color: #ccc; margin: 0 0 4px 16px; line-height: 0.8; font-size: 1.0em; font-weight: normal; } #header a, #header a:hover, #header a:visited { text-decoration: none; } .navbar .nav > .active > a, .navbar .nav > .active > a:hover, .navbar .nav > .active > a:focus { box-shadow: none; } .navbar .btn-navbar { margin-bottom: 5px; } </style> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Onboarding tutorial </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Onboarding tutorial</a></li></ul> <div class="nav-category">Publishing an LDES</div> <ul class="nav-list"><li class="nav-list-item active"><a href="/publishing/publishing_protected_LDES" class="nav-list-link active">Publishing a protected LDES</a></li><li class="nav-list-item"><a href="/publishing/basic_setup" class="nav-list-link">Basic setup</a></li><li class="nav-list-item"><a href="/publishing/minimal_server" class="nav-list-link">Minimal Server</a></li></ul> <div class="nav-category">Data pipeline</div> <ul class="nav-list"><li class="nav-list-item"><a href="/pipeline/minimal_workbench" class="nav-list-link">Minimal workbench</a></li><li class="nav-list-item"><a href="/pipeline/advanced_conversion" class="nav-list-link">Advanced conversion</a></li></ul> <div class="nav-category">Consuming an LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/consuming/consuming" class="nav-list-link">Setup a minimal LDES client</a></li></ul> <div class="nav-category">Protected LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/protected/publishing_protected_LDES" class="nav-list-link">Publishing a protected LDES</a></li></ul> </nav> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Onboarding tutorial" aria-label="Search Onboarding tutorial" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="publishing-and-accessing-a-protected-ldes"> <a href="#publishing-and-accessing-a-protected-ldes" class="anchor-heading" aria-labelledby="publishing-and-accessing-a-protected-ldes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Publishing and Accessing a Protected LDES </h1> <p>This tutorial will show you how to protect a LDES in order to prevent unauthorized access to a proprietary (or a public) data collection. It will also show how to expose the available LDES Server API as well as add and expose some metadata (using DCAT). In addition it will show you how to access such a protected LDES.</p> <p>Please see the <a href="../README.md">introduction</a> for the example data set and pre-requisites, as well as an overview of all examples.</p> <h2 id="ill-protect-you-from-the-hooded-claw"> <a href="#ill-protect-you-from-the-hooded-claw" class="anchor-heading" aria-labelledby="ill-protect-you-from-the-hooded-claw"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> I’ll Protect You From the Hooded Claw </h2> <p>The LDES Server allows you to ingest a data collection and offers one or more views which allows replicating the data collection in whole or a part of it. However, not all data collection can be made publicly available. You need to protect those data collection in some way to prevent unauthorized access. What you will typically do is configure some security system which expects a Data Client to identify itself (<em>authentication</em>) after which the security system verifies it the Data Client has access to the requested data (<em>authorization</em>).</p> <p>The LDES Server does not include such a security system because there are various ways for doing authentication anad authorization and no one-size fits all. You may want to protect the data simply with an API key (secret key shared with a Data Client), using OAuth2 (authorization only) and/or OpenID (based on OAuth2 adding authentication), etc. There are many open-source and commercial implementations available for these and other protocols, so we decided to not include this aspect into the LDES Server. This keeps the server lean and simple for serving open data collections.</p> <p>But, even if you have a open data collection you may want to add a security layer to it to keep usage statistics per Data Client, e.g. to enforce fair usage policies, etc. So, we will look into how you can protect a LDES using a simple API key per Data Client and how the Data Client can access such a LDES.</p> <p>This technique may also apply to a commercial data collection: as a Data Publisher you may also want to offer a part of your data to the public for publicity and marketing reasons but of course you will want to track its usage.</p> <p>We will show how you can protect a LDES and what changes are needed to retrieve such a LDES. We will use existing tutorials to kickstart our setup. To create and feed our LDES we can use the <a href="../advanced-conversion/README.md">advanced conversion setup</a> and to retrieve it we can use the <a href="../minimal-client/README.md">minimal client</a>. Later we will add a reverse proxy to shield the LDES Server from the outside and configure things in such a way that we have controlled access to both LDES Server administration and LDES replication &amp; synchronization. Obviously we will have to make changes on both the Data Publisher and the Data Client side.</p> <p>But first, let us setup the system without access limitation first to ensure everything works fine. As usual, we start by creating a docker compose file containing the services that we need.</p> <p>At the Data Publisher side we need a database for the LDES Server (<code class="language-plaintext highlighter-rouge">ldes-mongodb</code>), the LDES Server itself (<code class="language-plaintext highlighter-rouge">ldes-server</code>) and a workbench to feed the LDES Server (<code class="language-plaintext highlighter-rouge">server-workbench</code>). We can basically copy/paste the services from the <a href="../advanced-conversion/docker-compose.yml">advanced conversion docker compose</a> file:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">ldes-mongodb</span><span class="pi">:</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_ldes-mongodb</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">mongo:latest</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">27017:27017</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">protected-setup</span>

<span class="na">ldes-server</span><span class="pi">:</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_ldes-server</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">ldes/ldes-server:2.10.0-SNAPSHOT</span> <span class="c1"># you can safely change this to the latest 2.x.y version</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./ldes-server/application.yml:/application.yml:ro</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">9003:80</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">protected-setup</span>
  <span class="na">depends_on</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ldes-mongodb</span>
  <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">MANAGEMENT_TRACING_ENABLED=false</span> <span class="c1"># TODO: remove this when pull-based tracing implemented</span>
    <span class="pi">-</span> <span class="s">LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes}</span>

<span class="na">server-workbench</span><span class="pi">:</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_server-workbench</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">ldes/ldi-orchestrator:2.0.0-SNAPSHOT</span> <span class="c1"># you can safely change this to the latest 1.x.y version</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./server-workbench/config:/ldio/config:ro</span>
    <span class="pi">-</span> <span class="s">./server-workbench/application.yml:/ldio/application.yml:ro</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">9004:80</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">protected-setup</span> 
  <span class="na">profiles</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">delay-started</span>
</code></pre></div></div> <blockquote> <p><strong>Notes</strong>:</p> <ul> <li>for clarity we renamed the network as well as the container names</li> <li>we also renamed the workbench in order to stress that this is the workbench which feeds the LDES Server</li> <li>we moved the configuration files to organize the setup a bit</li> <li>we added an environment variable <code class="language-plaintext highlighter-rouge">LDES_SERVER_HOST_NAME</code> to allow changing the <code class="language-plaintext highlighter-rouge">ldes-server.host-name</code> in the <a href="./ldes-server/application.yml">server configuration</a> easier</li> </ul> </blockquote> <p>At the Data Client side we only need a workbench (<code class="language-plaintext highlighter-rouge">client-workbench</code>) which we can borrow from the <a href="../minimal-client/docker-compose.yml">minimal client docker compose</a> file:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">client-workbench</span><span class="pi">:</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_client-workbench</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">ldes/ldi-orchestrator:2.0.0-SNAPSHOT</span> <span class="c1"># you can safely change this to the latest 1.x.y version</span>
  <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">LDES_SERVER_URL=${LDES_SERVER_URL:-http://localhost:9003/ldes/occupancy/by-page}</span>
    <span class="pi">-</span> <span class="s">SINK_URL=${SINK_URL}</span>
    <span class="pi">-</span> <span class="s">MAX_REQUESTS_PER_MINUTE=${MAX_REQUESTS_PER_MINUTE:-50}</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./client-workbench/application.yml:/ldio/application.yml:ro</span>
  <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
  <span class="na">profiles</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">delay-started</span>
</code></pre></div></div> <blockquote> <p><strong>Notes</strong></p> <ul> <li>we renamed the container and the service</li> <li>we moved the configuration files</li> <li>we added a profile to prevent the client workbench to start ahead of time</li> </ul> </blockquote> <blockquote> <p><strong>Note</strong> that the client workbench uses the network of the host which is completely disconnected from the internal docker network used by the LDES Server and its database and workbench. The LDES Client component therefore needs to use the host name (<code class="language-plaintext highlighter-rouge">localhost</code>) and exposed server port (<code class="language-plaintext highlighter-rouge">9003</code>) to access the LDES. That is why we have configured both the <code class="language-plaintext highlighter-rouge">LDES_SERVER_HOST_NAME</code> and the <code class="language-plaintext highlighter-rouge">LDES_SERVER_URL</code> to start with <code class="language-plaintext highlighter-rouge">http://localhost:9003/</code>.</p> </blockquote> <p>What we have now is illustrated in the following system container diagram: <img src="./uml/unprotected-container.png" alt="container diagram" /></p> <p>Fig. 1 - Unprotected setup</p> <p>At this point we can run all the systems and verify that we receive the LDES members in the sink. Please open https://webhook.site/ in a browser windows and copy your unique URL. Copy the <code class="language-plaintext highlighter-rouge">.env</code> file to <code class="language-plaintext highlighter-rouge">user.env</code> and fill in your unique URL as the sink URL. Now start all systems using (in a bash shell):</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear

<span class="c"># start and wait for the server and database systems</span>
docker compose up <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldes-server$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># define the LDES and the view</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.by-page.ttl"</span>

<span class="c"># start and wait for the server workbench</span>
docker compose up server-workbench <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=server-workbench$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># start and wait for the client workbench</span>
docker compose <span class="nt">--env-file</span> user.env up client-workbench <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=client-workbench$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div> <p>Once you have verified that the members appear in the sink you can shutdown the systems and remove the private network for now using:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose <span class="nb">rm </span>client-workbench <span class="nt">--stop</span> <span class="nt">--force</span> <span class="nt">--volumes</span>
docker compose <span class="nb">rm </span>server-workbench <span class="nt">--stop</span> <span class="nt">--force</span> <span class="nt">--volumes</span>
docker compose down
</code></pre></div></div> <h2 id="its-a-well-kept-secret"> <a href="#its-a-well-kept-secret" class="anchor-heading" aria-labelledby="its-a-well-kept-secret"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> It’s a Well Kept Secret </h2> <p>Now that we have a unprotected but working setup we can make the necessary changes to enforce security. We will need to do a few things:</p> <ul> <li>add a reverse proxy that will accept the LDES requests on the server’s behalf, check authentication &amp; authorization and forward the request or return an access error</li> <li>not expose the LDES Server outside of the internal docker network so that the only way to access it is through the reverse proxy</li> <li>change the Data Client (and Data Publisher) configuration to retrieve the LDES through the reverse proxy</li> </ul> <p>The following illustration shows the setup after adding such a reverse proxy: <img src="./uml/protected-container.png" alt="container diagram" /></p> <p>Fig. 2 - Protected setup</p> <p>The first thing we need to asks ourselves is which endpoints we need to protect but before we can answer that question we need to know what endpoints are available. By default, the LDES Server does not make that immediately apparant but by exposing the so called <a href="https://swagger.io">Swagger UI</a> we can make the available API visible. If we add the following to the server configuration and launch it, we should see it:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">springdoc</span><span class="pi">:</span>
  <span class="na">swagger-ui</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/admin/doc/v1/swagger</span>
    <span class="na">urlsPrimaryName</span><span class="pi">:</span> <span class="s">base</span>
</code></pre></div></div> <blockquote> <p><strong>Note</strong> that we expose our swagger UI on the ‘admin’ API so we can protect it together with the rest of the admin API later.</p> </blockquote> <p>The <code class="language-plaintext highlighter-rouge">path</code> allows us to define the endpoint where the API information is visualized and the <code class="language-plaintext highlighter-rouge">urlsPrimaryName</code> allows us to choose which collection of APIs are displayed by default when we browse to the swagger UI endpoint. Now, in order to see it, we need to launch the server again:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear
docker compose up <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldes-server$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div> <p>Once started point your browser to http://localhost:9003/ldes/admin/doc/v1/swagger. You will be redirected to http://localhost:9003/ldes/admin/doc/v1/swagger-ui/index.html and in the top right corner you should see the <code class="language-plaintext highlighter-rouge">base</code> API collection selected and the base API displayed in the main window.</p> <p>When we look at this base API, we see that there is one endpoint for the ingest that expects a <code class="language-plaintext highlighter-rouge">POST</code> to an endpoint. Obviously we do not want anybody else than the server workbench to push members to our ingest endpoint so we need to disallow this through the reverse proxy. We can do that by disallowing <code class="language-plaintext highlighter-rouge">POST</code> requests through the reverse proxy but we need to ensure that we can still seed the LDES definitions, which also use <code class="language-plaintext highlighter-rouge">POST</code> requests towards the administrative API.</p> <p>Next we see that the LDES Server exposes an endpoint to retrieve metadata at the root <code class="language-plaintext highlighter-rouge">/</code> as well as the various data collections at <code class="language-plaintext highlighter-rouge">/{collection-name}</code> and their respective views at <code class="language-plaintext highlighter-rouge">/{collection-name}/{view-name}</code>, all using <code class="language-plaintext highlighter-rouge">GET</code> requests. Most likely we want the metadata to be publicly accessible so that our available data collections can be discovered. In other words, we want metadata crawlers to be able to retrieve the metadata (typically <a href="https://en.wikipedia.org/wiki/Data_Catalog_Vocabulary">DCAT</a> information) in an unsecured way so that we get some exposure for our data collections. Now, as for the collections and views themselves, we can setup the accessibility as required by our use cases. For this tutorial we will assume that only a few clients can access our LDES and view so we will protect them with an API key. In fact, we will assign one API key per client so we can distinguish them for statistical reasons (e.g. to enforce a fair use policy).</p> <p>Now, if we switch to the admin API (select <code class="language-plaintext highlighter-rouge">admin</code> in the top right dropdown) we see a lot more available endpoints for managing the LDES Server. Obviously, we want to protect the whole admin API (including the swagger UI) so that only we are allowed to manage it. We will do this by protecting it with yet another API key.</p> <blockquote> <p><strong>Note</strong> that an API key is not a very secure way of protecting an API. If somebody gets a hold of it, it can be misused. Therefore you should keep it a secret and use HTTPS instead of HTTP communication to prevent somebody sniffing the network and gaining access to the API key.</p> </blockquote> <p>Currently we do not expose any metadata for our LDES. Without going into details of DCAT, we will simply add the metadata (<a href="./ldes-server/metadata/catalog.ttl">catalog</a>, <a href="./ldes-server/metadata/occupancy.ttl">LDES metadata</a> and <a href="./ldes-server/metadata/occupancy.by-page.ttl">view metadata</a>) to our LDES Server by means of the admin API. We have kept the DCAT itself to the bare minimum as that is beyond the scope of the tutorial. It will be sufficient for our purpose. To try this please run:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># upload LDES &amp; view definitions</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.by-page.ttl"</span>

<span class="c"># upload metadata definitions</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/catalog.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/occupancy.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/ldes/admin/api/v1/eventstreams/occupancy/views/by-page/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/occupancy.by-page.ttl"</span>
</code></pre></div></div> <p>Now you can get the full DCAT if you request the root http://localhost:9003/ldes. It is a mix of the metadata definitions which we uploaded and server generated data, resulting in something like this:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@prefix by-page:   &lt;http://localhost:9003/ldes/occupancy/by-page/&gt; .
@prefix dcat:      &lt;http://www.w3.org/ns/dcat#&gt; .
@prefix ldes:      &lt;http://localhost:9003/ldes/&gt; .
@prefix occupancy: &lt;http://localhost:9003/ldes/occupancy/&gt; .
@prefix rdf:       &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs:      &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix terms:     &lt;http://purl.org/dc/terms/&gt; .
@prefix tree:      &lt;https://w3id.org/tree/&gt; .

ldes:occupancy  rdf:type   dcat:Dataset ;
        terms:conformsTo   tree:specification , &lt;https://w3id.org/ldes/specification&gt; ;
        terms:description  "LDES containing the occupancy of the various park+rides in Ghent in real time"@en ;
        terms:identifier   "http://localhost:9003/ldes/occupancy"^^rdfs:Literal ;
        terms:title        "Real time occupancy P+R (Gent) as LDES"@en .

&lt;https://w3id.org/ldes/specification&gt;
        rdf:type  terms:Standard .

occupancy:by-page  rdf:type  rdfs:Resource .

&lt;http://localhost:9003/ldes&gt;
        rdf:type           dcat:Catalog ;
        terms:description  "Offers an overview of the dataset(s) and data service(s) needed for the tutorial 'Publishing And Accessing a Protected LDES'."@en ;
        terms:identifier   "c403cbbd-9e4d-47a2-8bb5-41a7642701ba"^^rdfs:Literal ;
        terms:title        "Catalog for Publishing And Accessing a Protected LDES"@en ;
        dcat:dataset       ldes:occupancy ;
        dcat:service       by-page:description .

by-page:description  rdf:type     dcat:DataService ;
        terms:description         "Paged view for the occupancy of the various park+rides in Ghent in real time"@en ;
        terms:identifier          "http://localhost:9003/ldes/occupancy/by-page"^^rdfs:Literal ;
        terms:title               "Real time occupancy P+R (Gent) by page"@en ;
        dcat:endpointDescription  &lt;https://semiceu.github.io/LinkedDataEventStreams/&gt; ;
        dcat:endpointURL          occupancy:by-page ;
        dcat:servesDataset        ldes:occupancy .

tree:specification  rdf:type  terms:Standard .

&lt;https://semiceu.github.io/LinkedDataEventStreams/&gt;
        rdf:type  rdfs:Resource .
</code></pre></div></div> <p>As said before, we want this metadata to be publicly available, while limiting access to the admin API only to ourselves and the LDES &amp; the view to a couple of well-known clients, all by means of a unique API key. You can create these keys using one of the free online GUID generators (e.g. https://www.uuidgenerator.net/guid) or a password generator (e.g. https://www.avast.com/random-password-generator), etc.</p> <h3 id="add-a-reverse-proxy"> <a href="#add-a-reverse-proxy" class="anchor-heading" aria-labelledby="add-a-reverse-proxy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Add a Reverse Proxy </h3> <p>First we need to add the reverse proxy service to the docker compose file:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">reverse-proxy</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:stable</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_reverse-proxy</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">9005:8080</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./reverse-proxy/protect-ldes-server.conf:/etc/nginx/conf.d/protect-ldes-server.conf:ro</span>
  <span class="na">depends_on</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ldes-server</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">protected-setup</span> 
</code></pre></div></div> <p>Here we chose a well-known freely available component that we can setup as a reverse proxy. There are many options out there open-source and commercial. The configuration is highly dependent on the component that you use but the principles are mostly the same: you allow or disallow access to some URL for some HTTP verbs (GET, HEAD, POST, etc) based on some conditions.</p> <p>We’ll be using these three API keys for demonstration purposes:</p> <div class="table-wrapper"><table> <thead> <tr> <th>API key</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>admin-secret</td> <td>admin</td> </tr> <tr> <td>client-one-secret</td> <td>client 1</td> </tr> <tr> <td>client-two-secret</td> <td>client 2</td> </tr> </tbody> </table></div> <p>This translates to a mapping for our reverse proxy. Next we define an API key validation location, meaning that for the URLs we need to protect we use this internal virtual URL for verifying the presence and validity of the given API key. Finally we add our access rules. As previously said we need to:</p> <ul> <li>allow access to metadata to the public</li> <li>allow access to admin API (including the swagger API) only to administrators</li> <li>allow access to the LDES, the view and all view nodes for registered clients only</li> <li>do not allow access to the ingest endpoint (no POST to LDES endpoint allowed from outside)</li> </ul> <p>For this particular reverse proxy we end up with this <a href="./reverse-proxy/protect-ldes-server.conf">configuration</a> and can start the reverse proxy to test if the rules allow or disallow access correctly:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up reverse-proxy <span class="nt">-d</span>
</code></pre></div></div> <p>We have setup the reverse proxy to remap the LDES Server endpoints (all based at <code class="language-plaintext highlighter-rouge">/ldes</code>) a bit. The reverse proxy serves:</p> <ul> <li>the metadata at <code class="language-plaintext highlighter-rouge">/</code></li> <li>the admin API at <code class="language-plaintext highlighter-rouge">/admin</code></li> <li>the LDES, the view and its nodes at <code class="language-plaintext highlighter-rouge">/feed</code></li> </ul> <p>If we do not pass an API key we can retrieve only the metadata and not the LDES, the view, the admin API and the swagger UI:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear
curl <span class="nt">-I</span> http://localhost:9005/
curl <span class="nt">-I</span> http://localhost:9005/feed/occupancy
curl <span class="nt">-I</span> http://localhost:9005/feed/occupancy/by-page
curl <span class="nt">-I</span> http://localhost:9005/admin/api/v1/eventstreams
</code></pre></div></div> <p>Public access is only allowed (HTTP 200) for the first call, all other calls are unauthenticated (HTTP 401).</p> <blockquote> <p><strong>Note</strong> that we pass <code class="language-plaintext highlighter-rouge">-I</code> in order to only retrieve the headers, not the actual content.</p> </blockquote> <p>If we pass a client API key we can retrieve the metadata, the LDES and the view but we cannot use the admin API:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: client-one-secret"</span> http://localhost:9005/
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: client-one-secret"</span> http://localhost:9005/feed/occupancy
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: client-one-secret"</span> http://localhost:9005/feed/occupancy/by-page
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: client-one-secret"</span> http://localhost:9005/admin/api/v1/eventstreams
</code></pre></div></div> <p>All but the last call should succeed (HTTP 200) while the last one is forbidden (HTTP 403) because we are authenticated but not authorized to use the admin API.</p> <blockquote> <p><strong>Note</strong> that we need to pass the API key using the header <code class="language-plaintext highlighter-rouge">x-api-key: &lt;well-known-key&gt;</code>.</p> </blockquote> <p>Finally, if we pass the admin API key all calls should be possible:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> http://localhost:9005/
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> http://localhost:9005/feed/occupancy
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> http://localhost:9005/feed/occupancy/by-page
curl <span class="nt">-I</span> <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> http://localhost:9005/admin/api/v1/eventstreams
</code></pre></div></div> <p>Now all calls succeed. Great!</p> <p>We need to verify one more rule: nobody (not even an administrator!) should we able to send data to the ingest endpoint of the LDES server:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear
curl <span class="nt">-X</span> POST <span class="nt">-i</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="nt">-d</span> @./data/member.ttl http://localhost:9005/feed/occupancy
curl <span class="nt">-X</span> POST <span class="nt">-i</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="nt">-d</span> @./data/member.ttl http://localhost:9005/feed/occupancy <span class="nt">-H</span> <span class="s2">"x-api-key: client-one-secret"</span>
curl <span class="nt">-X</span> POST <span class="nt">-i</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="nt">-d</span> @./data/member.ttl http://localhost:9005/feed/occupancy <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span>
</code></pre></div></div> <p>All calls should fail with a forbidden (HTTP 403).</p> <blockquote> <p><strong>Note</strong> that it would be better to return method not allowed (HTTP 405) but that seems to be a challenge in this specific reverse proxy configuration.</p> </blockquote> <p>One final thing to test is if we can POST to the admin endpoint, e.g. to define a LDES or add metadata.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/catalog.ttl"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/dcat"</span> <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span>
</code></pre></div></div> <p>Should return an error similar to <code class="language-plaintext highlighter-rouge">Resource of type: dcat-catalog with id: c403cbbd-9e4d-47a2-8bb5-41a7642701ba already exists.</code> because we have already defined the catalog. But, this is great news because this means the reverse proxy let the request go through and the LDES Server returns an error response.</p> <h3 id="do-not-expose-the-ldes-server"> <a href="#do-not-expose-the-ldes-server" class="anchor-heading" aria-labelledby="do-not-expose-the-ldes-server"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Do Not Expose the LDES Server </h3> <p>Now that everything is working great we can simply remove (or comment out) the port mapping of the server in the docker compose file as we do not need and do not want any direct access to it:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">ldes-server</span><span class="pi">:</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">protected-setup_ldes-server</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">ldes/ldes-server:2.10.0-SNAPSHOT</span> <span class="c1"># you can safely change this to the latest 2.x.y version</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./ldes-server/application.yml:/application.yml:ro</span>
  <span class="c1"># ports:</span>
  <span class="c1">#   - 9003:80</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">protected-setup</span>
  <span class="na">depends_on</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ldes-mongodb</span>
  <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">MANAGEMENT_TRACING_ENABLED=false</span> <span class="c1"># TODO: remove this when pull-based tracing implemented</span>
    <span class="pi">-</span> <span class="s">LDES_SERVER_HOST_NAME=${LDES_SERVER_HOST_NAME:-http://localhost:9003/ldes}</span>
</code></pre></div></div> <h3 id="access-the-ldes-server-through-the-reverse-proxy"> <a href="#access-the-ldes-server-through-the-reverse-proxy" class="anchor-heading" aria-labelledby="access-the-ldes-server-through-the-reverse-proxy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Access the LDES Server Through the Reverse Proxy </h3> <p>Once the LDES Server is not directly accessible anymore, we need to define some environment variables to use the reverse proxy instead:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDES_SERVER_HOST_NAME=http://localhost:9005/feed
LDES_SERVER_URL=http://localhost:9005/feed/occupancy
</code></pre></div></div> <p>and we need to pass our <code class="language-plaintext highlighter-rouge">user.env</code> file to all our docker compose commands.</p> <p>Of course, we should not forget the most important part: configure the LDES Client to pass a API key when requesting the LDES nodes. In the client workbench we need to change the LDES CLient component configuration to include this API key:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">input</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">Ldio:LdesClient</span>
  <span class="na">config</span><span class="pi">:</span>
    <span class="na">urls</span><span class="pi">:</span> 
      <span class="pi">-</span> <span class="s">${LDES_SERVER_URL}</span>
    <span class="na">sourceFormat</span><span class="pi">:</span> <span class="s">application/n-quads</span>
    <span class="na">auth</span><span class="pi">:</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">API_KEY</span>
      <span class="na">api-key-header</span><span class="pi">:</span> <span class="s">x-api-key</span>
      <span class="na">api-key</span><span class="pi">:</span> <span class="s">client-two-secret</span>
</code></pre></div></div> <p>Show time! But first bring down all systems so we can start with a clean slate:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose down
</code></pre></div></div> <h2 id="putting-it-all-together"> <a href="#putting-it-all-together" class="anchor-heading" aria-labelledby="putting-it-all-together"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Putting It All Together </h2> <p>To launch all the systems and configure it all you can run the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear

<span class="c"># start and wait for the server and database systems</span>
docker compose <span class="nt">--env-file</span> user.env up <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldes-server$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># upload LDES &amp; view definitions</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/eventstreams"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/eventstreams/occupancy/views"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/definitions/occupancy.by-page.ttl"</span>

<span class="c"># upload metadata definitions</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/catalog.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/eventstreams/occupancy/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/occupancy.ttl"</span>
curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"x-api-key: admin-secret"</span> <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9005/admin/api/v1/eventstreams/occupancy/views/by-page/dcat"</span> <span class="nt">-d</span> <span class="s2">"@./ldes-server/metadata/occupancy.by-page.ttl"</span>

<span class="c"># start and wait for the server workbench</span>
docker compose <span class="nt">--env-file</span> user.env up server-workbench <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=server-workbench$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>

<span class="c"># start and wait for the client workbench</span>
docker compose <span class="nt">--env-file</span> user.env up client-workbench <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=client-workbench$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div> <p>It all goes well (and it should!) you will see the LDES members appear in the sink.</p> <h2 id="its-been-a-long-day"> <a href="#its-been-a-long-day" class="anchor-heading" aria-labelledby="its-been-a-long-day"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> It’s Been a Long Day </h2> <p>We have shown you how to enable the swagger UI, how to provide metadata for your LDES views and, of course, how to access a protected LDES. In addition we have shown you how you can protect a LDES using a API key but if you require a stronger way of securing access have a look at other authentication and authorization mechanisms. The <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/ldio/ldio-core/ldio-http-requester">documentation</a> explains how to configure the LDES client in case you need to access an OAuth2/OpenID protected LDES.</p> <p>Now that you have verified that the members appear in the sink you can shutdown the systems and remove the private network using:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose <span class="nb">rm </span>client-workbench <span class="nt">--stop</span> <span class="nt">--force</span> <span class="nt">--volumes</span>
docker compose <span class="nb">rm </span>server-workbench <span class="nt">--stop</span> <span class="nt">--force</span> <span class="nt">--volumes</span>
docker compose down
</code></pre></div></div> </main> <hr> <footer> <p class="text-small text-grey-dk-100 mb-0"></p> <div class="d-flex mt-2"> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
