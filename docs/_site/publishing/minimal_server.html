<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Minimal Server | Onboarding tutorial</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="Minimal Server" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Setting Up a Minimal LDES Server This quick start guide will show you how to setup a minimal LDES server to accept linked data members. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Enter the LDES Server The LDES Server is one of the components built as part of a large project on creating a data space for Flanders (sorry, Dutch only) for Data Owners, Data Publishers and Data Clients. Its main purpose is to accept data set members, store them in external storage and allow to retrieve the data set as a LDES for replication as a whole or just a subset of the data set. However, the real benefit of LDES lies in its ability to allow Data Clients to keep in sync with changes that occur on the data set. Data Clients are typically not only interested in the current state of a data set but also in the historical changes that occurred, e.g. in order to understand the evolution of air quality in a city you need the analyze the measurements of some sensors over time. The LDES Server expects the data that it receives to be a so called version object, that is, the state of something at some point in time. This allows you to retrieve the changes of the object state from initial state (first version) to the current state (latest version) and due to the ability to keep in sync, even the future state (future versions). Pretty cool! Don’t you think? Where Do We Keep This Gem? As each Data Publisher needs to publish its own data set, the LDES Server is offered as a Docker image that can be configured to get the job done in a custom way and according to the needs of the Data Publisher. The Docker images are available on Docker Hub. Here you can find the stable releases. Notice that some tags end with -SNAPSHOT. These images can safely be used. The only difference with the ones without this label is that validity with the official specification did not yet occur. Functionality, they are exactly the same. Every two weeks (our sprint duration) a new images is created and labeled with semantic versioning. You can expect backwards compatible images to keep the same major version number and have an increased minor version number. Very occasionally we create a patch release with a non-zero patch number. Note that our Github repository contains many more images which are created of our development branch. Please use these only if really needed as they can and will contain some issues. Setup Up the Basics As mentioned in the pre-requisites, you need some minimal knowledge on Docker Compose as we use it to run both the LDES Server and the required data storage system as a container. Currently we only support MongoDB for storing the LDES members and other data. On Docker Hub you can found the container images. Depending on your host hardware (e.g. a Raspberry Pi) you may need an older version, otherwise feel free to use the latest. Some other MongoDB compatible (cloud) databases can also be used (e.g. CosmosDB and DocumentDB). In the future we may add other databases. If you look into the Docker Compose file, you will see that we define one (private) network for our two services: the LDES Server and the MongoDB. This allows the LDES Server to refer to the MongoDB by its service name ldes-mongodb but also requires us to map the internal port numbers (respectively 8080 and 27017) to external port numbers (respectively 9003 and 27017) in order to be able to reach the services (respectively http://localhost:9003 and mongodb://localhost:27017, or even mongodb://locahost). We’ll see in a minute where the internal ports come from. Furthermore the compose file contains names for our containers, the images and tags to use as a definition (i.e. a cookie-cutter) for our containers, a dependency on the MongoDB so the LDES Server is started after the database container, and finally a (read-only) volume mapping of our LDES Server configuration file into the container file-system to allow our LDES Server to use it. The LDES Server configuration file is pretty straight-forward as well. It contains the URI (spring.data.mongodb.uri), basically the database connection string, of our MongoDB database. Note that the format is &lt;scheme&gt;://&lt;server&gt;:&lt;port&gt;/&lt;database&gt; where the &lt;scheme&gt; is always mongodb, the &lt;server&gt; is the service name in the composer file (i.e. ldes-mongodb), the &lt;port&gt; is the default port number 27017 and has been omitted, and finally, &lt;database&gt; is the name of the database that will hold our LDES data, for which we chose minimal-server. In addition, we need to specify that our LDES Server uses the MongoDB driver to automatically create the necessary indexes (even on CosmosDB!). We also need to specify the external base path of our LDES Server so that the links within the LDES can be followed. Because we do port mapping in the compose file, we set our LDES Server to be available at http://localhost:9003 in this tutorial. But not yet, we first need to start our containers. Ready for some action? Let’s get our hands dirty! Systems Ready? 3, 2, 1 .. Ignition! Well, enough theory! Let’s get this thing going and see how we can actually feed the LDES Server with some data. To run the commands below you need to use a bash command shell. This allows us to keep the commands the same across the main three operating systems: Linux, Windows and MacOS. But, if you cloned this repository locally you already have a bash shell! It comes with your git installation. To launch the LDES Server and the MongoDB containers: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Note that we start the containers as deamons and then wait for the LDES server to be available by checking every second that the container log file contains the magic string Started Application in. You could also simply start it with docker compose up and wait until you actually see this magic string, but then you need to open a new command shell to execute the commands in the next sections. Defining Our First LDES As soon as the systems are started and ready we need to tell our LDES Server what data set we want to store because the LDES Server can host more than one data set. To manage this the LDES Server offers an administration API. We will explore this API later but for now we simply send the LDES definition to this API so that we can store some data in our data set. To define the LDES: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams&quot; -d &quot;@./definitions/occupancy.ttl&quot; This may look like a bit of hocus-pocus but it is truly very simple. The LDES definition is a turtle file which is a way of serializing RDF. The definition file starts with a few declarations allowing for some short-hand notation so we do not get lost in translation. The other lines are the interesting part. First we start by saying that we define a LDES (&lt;/occupancy&gt; a ldes:EventStream) and that we want the server to accept members and fetching the LDES on a sub-path (/occupancy). Then, we tell it what type our members will be (sh:targetClass :offStreetParkingGround, or http://www.w3.org/ns/shacl#targetClass https://example.org/ns/mobility#offStreetParkingGround in full). Finally, we tell it that these members are version objects of the state object identified by the member property dcterms:isVersionOf and can be distinguised by the member property prov:generatedAtTime. Essentially, these properties allow us to group members to find all versions of something respectively to order them to know which member precedes another member. We can verify that the LDES is actually known to the server by requesting it by its endpoint. This endpoint depends on several things: the port mapping, the base path of the server and the data set sub-path we defined in the LDES definition. In this example it is http://localhost:9003/occupancy. To check out our LDES: curl http://localhost:9003/occupancy Storing Our First Member Once we have defined our LDES we can finally send our first member to the endpoint we defined and the LDES Server can store it. To ingest a member: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/occupancy&quot; -d &quot;@./data/member.ttl&quot; Note that the member is some linked data serialized as a turtle file for which the default file extension is .ttl and the mime type is text/turtle. The LDES server can accept a few more RDF serialization formats, each identified by their own mime type. Creating Our First View Now that we have ingested a member, you may wonder how we can check that it is actually in there? And how will Data Clients retrieve our small data set. The LDES Server can offer various views on each data set so we need to tell it how we want the LDES to be available for consumption. We do this again using the administration API by sending a view definition to the LDES Server and attaching it to our LDES. The LDES Server will start a background process to create this LDES view and offer the data set in fragments. Such a fragment is a number of members as well as information about the LDES and ways to navigate to the other members from the data set. See the Tree specification on which the LDES specification is built for details. Essentially, the fragments create a (typically hierarchical but possibly a graph) structure for navigating between them by defining the relation between themselves and their related fragments. Data Clients can then navigate to all or a part of these relations and therefore reach all or a subset of the data set. But enough theory! Let’s define the view and request the member. To define the LDES view: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./definitions/occupancy.by-page.ttl&quot; The view definition is a turtle file very similar to the LDES definition. It contains the view definition (it is a tree node) and how to get to this view (&lt;/occupancy/by-page&gt; a tree:Node). It set the number of members per fragment (tree:pageSize &quot;50&quot;^^xsd:integer). That’s all folks! To check out our LDES: curl http://localhost:9003/occupancy/by-page Note that you can create more than one view of a LDES, even for simple pagination by specifying a different view URI and page size. Later when we learn about retention policies and different fragmentation strategies, this may make more sense. For now remember that you can create a view before or after you ingest data, You can delete views and re-create them with different options. For this, you will need to use the administration API. Later, we will show you how to enable the swagger to explore this API. Show Me the Data! Depending on the size of the data set the LDES Server magic may take a while to make all members available, but you can already get the first members almost immediately. To retrieve the data set: curl http://localhost:9003/occupancy/by-page?pageNumber=1 All Good Things Must Come To an End That’s it. Now you have an understanding what the LDES Server is about, where you can find it and how to set it up. You have learned how to create a LDES and a view for it as well as how to ingest and retrieve your data set. It’s time now to stop the LDES Server and its storage. To bring the containers down and remove the private network: docker compose down" /> <meta property="og:description" content="Setting Up a Minimal LDES Server This quick start guide will show you how to setup a minimal LDES server to accept linked data members. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Enter the LDES Server The LDES Server is one of the components built as part of a large project on creating a data space for Flanders (sorry, Dutch only) for Data Owners, Data Publishers and Data Clients. Its main purpose is to accept data set members, store them in external storage and allow to retrieve the data set as a LDES for replication as a whole or just a subset of the data set. However, the real benefit of LDES lies in its ability to allow Data Clients to keep in sync with changes that occur on the data set. Data Clients are typically not only interested in the current state of a data set but also in the historical changes that occurred, e.g. in order to understand the evolution of air quality in a city you need the analyze the measurements of some sensors over time. The LDES Server expects the data that it receives to be a so called version object, that is, the state of something at some point in time. This allows you to retrieve the changes of the object state from initial state (first version) to the current state (latest version) and due to the ability to keep in sync, even the future state (future versions). Pretty cool! Don’t you think? Where Do We Keep This Gem? As each Data Publisher needs to publish its own data set, the LDES Server is offered as a Docker image that can be configured to get the job done in a custom way and according to the needs of the Data Publisher. The Docker images are available on Docker Hub. Here you can find the stable releases. Notice that some tags end with -SNAPSHOT. These images can safely be used. The only difference with the ones without this label is that validity with the official specification did not yet occur. Functionality, they are exactly the same. Every two weeks (our sprint duration) a new images is created and labeled with semantic versioning. You can expect backwards compatible images to keep the same major version number and have an increased minor version number. Very occasionally we create a patch release with a non-zero patch number. Note that our Github repository contains many more images which are created of our development branch. Please use these only if really needed as they can and will contain some issues. Setup Up the Basics As mentioned in the pre-requisites, you need some minimal knowledge on Docker Compose as we use it to run both the LDES Server and the required data storage system as a container. Currently we only support MongoDB for storing the LDES members and other data. On Docker Hub you can found the container images. Depending on your host hardware (e.g. a Raspberry Pi) you may need an older version, otherwise feel free to use the latest. Some other MongoDB compatible (cloud) databases can also be used (e.g. CosmosDB and DocumentDB). In the future we may add other databases. If you look into the Docker Compose file, you will see that we define one (private) network for our two services: the LDES Server and the MongoDB. This allows the LDES Server to refer to the MongoDB by its service name ldes-mongodb but also requires us to map the internal port numbers (respectively 8080 and 27017) to external port numbers (respectively 9003 and 27017) in order to be able to reach the services (respectively http://localhost:9003 and mongodb://localhost:27017, or even mongodb://locahost). We’ll see in a minute where the internal ports come from. Furthermore the compose file contains names for our containers, the images and tags to use as a definition (i.e. a cookie-cutter) for our containers, a dependency on the MongoDB so the LDES Server is started after the database container, and finally a (read-only) volume mapping of our LDES Server configuration file into the container file-system to allow our LDES Server to use it. The LDES Server configuration file is pretty straight-forward as well. It contains the URI (spring.data.mongodb.uri), basically the database connection string, of our MongoDB database. Note that the format is &lt;scheme&gt;://&lt;server&gt;:&lt;port&gt;/&lt;database&gt; where the &lt;scheme&gt; is always mongodb, the &lt;server&gt; is the service name in the composer file (i.e. ldes-mongodb), the &lt;port&gt; is the default port number 27017 and has been omitted, and finally, &lt;database&gt; is the name of the database that will hold our LDES data, for which we chose minimal-server. In addition, we need to specify that our LDES Server uses the MongoDB driver to automatically create the necessary indexes (even on CosmosDB!). We also need to specify the external base path of our LDES Server so that the links within the LDES can be followed. Because we do port mapping in the compose file, we set our LDES Server to be available at http://localhost:9003 in this tutorial. But not yet, we first need to start our containers. Ready for some action? Let’s get our hands dirty! Systems Ready? 3, 2, 1 .. Ignition! Well, enough theory! Let’s get this thing going and see how we can actually feed the LDES Server with some data. To run the commands below you need to use a bash command shell. This allows us to keep the commands the same across the main three operating systems: Linux, Windows and MacOS. But, if you cloned this repository locally you already have a bash shell! It comes with your git installation. To launch the LDES Server and the MongoDB containers: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Note that we start the containers as deamons and then wait for the LDES server to be available by checking every second that the container log file contains the magic string Started Application in. You could also simply start it with docker compose up and wait until you actually see this magic string, but then you need to open a new command shell to execute the commands in the next sections. Defining Our First LDES As soon as the systems are started and ready we need to tell our LDES Server what data set we want to store because the LDES Server can host more than one data set. To manage this the LDES Server offers an administration API. We will explore this API later but for now we simply send the LDES definition to this API so that we can store some data in our data set. To define the LDES: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams&quot; -d &quot;@./definitions/occupancy.ttl&quot; This may look like a bit of hocus-pocus but it is truly very simple. The LDES definition is a turtle file which is a way of serializing RDF. The definition file starts with a few declarations allowing for some short-hand notation so we do not get lost in translation. The other lines are the interesting part. First we start by saying that we define a LDES (&lt;/occupancy&gt; a ldes:EventStream) and that we want the server to accept members and fetching the LDES on a sub-path (/occupancy). Then, we tell it what type our members will be (sh:targetClass :offStreetParkingGround, or http://www.w3.org/ns/shacl#targetClass https://example.org/ns/mobility#offStreetParkingGround in full). Finally, we tell it that these members are version objects of the state object identified by the member property dcterms:isVersionOf and can be distinguised by the member property prov:generatedAtTime. Essentially, these properties allow us to group members to find all versions of something respectively to order them to know which member precedes another member. We can verify that the LDES is actually known to the server by requesting it by its endpoint. This endpoint depends on several things: the port mapping, the base path of the server and the data set sub-path we defined in the LDES definition. In this example it is http://localhost:9003/occupancy. To check out our LDES: curl http://localhost:9003/occupancy Storing Our First Member Once we have defined our LDES we can finally send our first member to the endpoint we defined and the LDES Server can store it. To ingest a member: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/occupancy&quot; -d &quot;@./data/member.ttl&quot; Note that the member is some linked data serialized as a turtle file for which the default file extension is .ttl and the mime type is text/turtle. The LDES server can accept a few more RDF serialization formats, each identified by their own mime type. Creating Our First View Now that we have ingested a member, you may wonder how we can check that it is actually in there? And how will Data Clients retrieve our small data set. The LDES Server can offer various views on each data set so we need to tell it how we want the LDES to be available for consumption. We do this again using the administration API by sending a view definition to the LDES Server and attaching it to our LDES. The LDES Server will start a background process to create this LDES view and offer the data set in fragments. Such a fragment is a number of members as well as information about the LDES and ways to navigate to the other members from the data set. See the Tree specification on which the LDES specification is built for details. Essentially, the fragments create a (typically hierarchical but possibly a graph) structure for navigating between them by defining the relation between themselves and their related fragments. Data Clients can then navigate to all or a part of these relations and therefore reach all or a subset of the data set. But enough theory! Let’s define the view and request the member. To define the LDES view: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./definitions/occupancy.by-page.ttl&quot; The view definition is a turtle file very similar to the LDES definition. It contains the view definition (it is a tree node) and how to get to this view (&lt;/occupancy/by-page&gt; a tree:Node). It set the number of members per fragment (tree:pageSize &quot;50&quot;^^xsd:integer). That’s all folks! To check out our LDES: curl http://localhost:9003/occupancy/by-page Note that you can create more than one view of a LDES, even for simple pagination by specifying a different view URI and page size. Later when we learn about retention policies and different fragmentation strategies, this may make more sense. For now remember that you can create a view before or after you ingest data, You can delete views and re-create them with different options. For this, you will need to use the administration API. Later, we will show you how to enable the swagger to explore this API. Show Me the Data! Depending on the size of the data set the LDES Server magic may take a while to make all members available, but you can already get the first members almost immediately. To retrieve the data set: curl http://localhost:9003/occupancy/by-page?pageNumber=1 All Good Things Must Come To an End That’s it. Now you have an understanding what the LDES Server is about, where you can find it and how to set it up. You have learned how to create a LDES and a view for it as well as how to ingest and retrieve your data set. It’s time now to stop the LDES Server and its storage. To bring the containers down and remove the private network: docker compose down" /> <link rel="canonical" href="http://localhost:4000/publishing/minimal_server" /> <meta property="og:url" content="http://localhost:4000/publishing/minimal_server" /> <meta property="og:site_name" content="Onboarding tutorial" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Minimal Server" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Setting Up a Minimal LDES Server This quick start guide will show you how to setup a minimal LDES server to accept linked data members. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Enter the LDES Server The LDES Server is one of the components built as part of a large project on creating a data space for Flanders (sorry, Dutch only) for Data Owners, Data Publishers and Data Clients. Its main purpose is to accept data set members, store them in external storage and allow to retrieve the data set as a LDES for replication as a whole or just a subset of the data set. However, the real benefit of LDES lies in its ability to allow Data Clients to keep in sync with changes that occur on the data set. Data Clients are typically not only interested in the current state of a data set but also in the historical changes that occurred, e.g. in order to understand the evolution of air quality in a city you need the analyze the measurements of some sensors over time. The LDES Server expects the data that it receives to be a so called version object, that is, the state of something at some point in time. This allows you to retrieve the changes of the object state from initial state (first version) to the current state (latest version) and due to the ability to keep in sync, even the future state (future versions). Pretty cool! Don’t you think? Where Do We Keep This Gem? As each Data Publisher needs to publish its own data set, the LDES Server is offered as a Docker image that can be configured to get the job done in a custom way and according to the needs of the Data Publisher. The Docker images are available on Docker Hub. Here you can find the stable releases. Notice that some tags end with -SNAPSHOT. These images can safely be used. The only difference with the ones without this label is that validity with the official specification did not yet occur. Functionality, they are exactly the same. Every two weeks (our sprint duration) a new images is created and labeled with semantic versioning. You can expect backwards compatible images to keep the same major version number and have an increased minor version number. Very occasionally we create a patch release with a non-zero patch number. Note that our Github repository contains many more images which are created of our development branch. Please use these only if really needed as they can and will contain some issues. Setup Up the Basics As mentioned in the pre-requisites, you need some minimal knowledge on Docker Compose as we use it to run both the LDES Server and the required data storage system as a container. Currently we only support MongoDB for storing the LDES members and other data. On Docker Hub you can found the container images. Depending on your host hardware (e.g. a Raspberry Pi) you may need an older version, otherwise feel free to use the latest. Some other MongoDB compatible (cloud) databases can also be used (e.g. CosmosDB and DocumentDB). In the future we may add other databases. If you look into the Docker Compose file, you will see that we define one (private) network for our two services: the LDES Server and the MongoDB. This allows the LDES Server to refer to the MongoDB by its service name ldes-mongodb but also requires us to map the internal port numbers (respectively 8080 and 27017) to external port numbers (respectively 9003 and 27017) in order to be able to reach the services (respectively http://localhost:9003 and mongodb://localhost:27017, or even mongodb://locahost). We’ll see in a minute where the internal ports come from. Furthermore the compose file contains names for our containers, the images and tags to use as a definition (i.e. a cookie-cutter) for our containers, a dependency on the MongoDB so the LDES Server is started after the database container, and finally a (read-only) volume mapping of our LDES Server configuration file into the container file-system to allow our LDES Server to use it. The LDES Server configuration file is pretty straight-forward as well. It contains the URI (spring.data.mongodb.uri), basically the database connection string, of our MongoDB database. Note that the format is &lt;scheme&gt;://&lt;server&gt;:&lt;port&gt;/&lt;database&gt; where the &lt;scheme&gt; is always mongodb, the &lt;server&gt; is the service name in the composer file (i.e. ldes-mongodb), the &lt;port&gt; is the default port number 27017 and has been omitted, and finally, &lt;database&gt; is the name of the database that will hold our LDES data, for which we chose minimal-server. In addition, we need to specify that our LDES Server uses the MongoDB driver to automatically create the necessary indexes (even on CosmosDB!). We also need to specify the external base path of our LDES Server so that the links within the LDES can be followed. Because we do port mapping in the compose file, we set our LDES Server to be available at http://localhost:9003 in this tutorial. But not yet, we first need to start our containers. Ready for some action? Let’s get our hands dirty! Systems Ready? 3, 2, 1 .. Ignition! Well, enough theory! Let’s get this thing going and see how we can actually feed the LDES Server with some data. To run the commands below you need to use a bash command shell. This allows us to keep the commands the same across the main three operating systems: Linux, Windows and MacOS. But, if you cloned this repository locally you already have a bash shell! It comes with your git installation. To launch the LDES Server and the MongoDB containers: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldes-server$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done Note that we start the containers as deamons and then wait for the LDES server to be available by checking every second that the container log file contains the magic string Started Application in. You could also simply start it with docker compose up and wait until you actually see this magic string, but then you need to open a new command shell to execute the commands in the next sections. Defining Our First LDES As soon as the systems are started and ready we need to tell our LDES Server what data set we want to store because the LDES Server can host more than one data set. To manage this the LDES Server offers an administration API. We will explore this API later but for now we simply send the LDES definition to this API so that we can store some data in our data set. To define the LDES: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams&quot; -d &quot;@./definitions/occupancy.ttl&quot; This may look like a bit of hocus-pocus but it is truly very simple. The LDES definition is a turtle file which is a way of serializing RDF. The definition file starts with a few declarations allowing for some short-hand notation so we do not get lost in translation. The other lines are the interesting part. First we start by saying that we define a LDES (&lt;/occupancy&gt; a ldes:EventStream) and that we want the server to accept members and fetching the LDES on a sub-path (/occupancy). Then, we tell it what type our members will be (sh:targetClass :offStreetParkingGround, or http://www.w3.org/ns/shacl#targetClass https://example.org/ns/mobility#offStreetParkingGround in full). Finally, we tell it that these members are version objects of the state object identified by the member property dcterms:isVersionOf and can be distinguised by the member property prov:generatedAtTime. Essentially, these properties allow us to group members to find all versions of something respectively to order them to know which member precedes another member. We can verify that the LDES is actually known to the server by requesting it by its endpoint. This endpoint depends on several things: the port mapping, the base path of the server and the data set sub-path we defined in the LDES definition. In this example it is http://localhost:9003/occupancy. To check out our LDES: curl http://localhost:9003/occupancy Storing Our First Member Once we have defined our LDES we can finally send our first member to the endpoint we defined and the LDES Server can store it. To ingest a member: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/occupancy&quot; -d &quot;@./data/member.ttl&quot; Note that the member is some linked data serialized as a turtle file for which the default file extension is .ttl and the mime type is text/turtle. The LDES server can accept a few more RDF serialization formats, each identified by their own mime type. Creating Our First View Now that we have ingested a member, you may wonder how we can check that it is actually in there? And how will Data Clients retrieve our small data set. The LDES Server can offer various views on each data set so we need to tell it how we want the LDES to be available for consumption. We do this again using the administration API by sending a view definition to the LDES Server and attaching it to our LDES. The LDES Server will start a background process to create this LDES view and offer the data set in fragments. Such a fragment is a number of members as well as information about the LDES and ways to navigate to the other members from the data set. See the Tree specification on which the LDES specification is built for details. Essentially, the fragments create a (typically hierarchical but possibly a graph) structure for navigating between them by defining the relation between themselves and their related fragments. Data Clients can then navigate to all or a part of these relations and therefore reach all or a subset of the data set. But enough theory! Let’s define the view and request the member. To define the LDES view: curl -X POST -H &quot;content-type: text/turtle&quot; &quot;http://localhost:9003/admin/api/v1/eventstreams/occupancy/views&quot; -d &quot;@./definitions/occupancy.by-page.ttl&quot; The view definition is a turtle file very similar to the LDES definition. It contains the view definition (it is a tree node) and how to get to this view (&lt;/occupancy/by-page&gt; a tree:Node). It set the number of members per fragment (tree:pageSize &quot;50&quot;^^xsd:integer). That’s all folks! To check out our LDES: curl http://localhost:9003/occupancy/by-page Note that you can create more than one view of a LDES, even for simple pagination by specifying a different view URI and page size. Later when we learn about retention policies and different fragmentation strategies, this may make more sense. For now remember that you can create a view before or after you ingest data, You can delete views and re-create them with different options. For this, you will need to use the administration API. Later, we will show you how to enable the swagger to explore this API. Show Me the Data! Depending on the size of the data set the LDES Server magic may take a while to make all members available, but you can already get the first members almost immediately. To retrieve the data set: curl http://localhost:9003/occupancy/by-page?pageNumber=1 All Good Things Must Come To an End That’s it. Now you have an understanding what the LDES Server is about, where you can find it and how to set it up. You have learned how to create a LDES and a view for it as well as how to ingest and retrieve your data set. It’s time now to stop the LDES Server and its storage. To bring the containers down and remove the private network: docker compose down","headline":"Minimal Server","url":"http://localhost:4000/publishing/minimal_server"}</script> <!-- End Jekyll SEO tag --> <div class="test-header" data-v-df634f57="" data-v-7a7a37b1=""> <div class="global-header" data-v-df634f57=""><img src="/assets/images/LOGO_Vlaanderen_NIV2.svg" alt="Vlaanderen" data-v-df634f57=""><img class="small-global-header-divider" src="/assets/images/divider_globalheader.svg" alt="divider" data-v-df634f57=""><span class="header-title header-font" data-v-df634f57="">Vlaamse Smart Data Space</span><span class="spacer" data-v-df634f57=""></span> <div id="help-needed" data-v-df634f57=""><span class="header-font" data-v-df634f57="">Hulp nodig</span><a id="help" href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/contact"><img class="question-menu-item" src="/assets/images/question-mark.svg" alt="?" data-v-df634f57=""></a></div> </div> <hr class="divider" data-v-df634f57=""> </div> <div class="navbar navbar-fixed-top"> <div class="navbar-inner"> <div class="container-fluid"> <a href="https://informatievlaanderen.github.io/VSDS-Tech-Docs/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Home</span> </button> </a> <a href="https://github.com/Informatievlaanderen/VSDS-Onboarding-Example"> <button type="button" class="btn btn-navbar custom-border-activated" > <span class="nav-icon-bar">Tutorial</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Linked Data Interactions</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-LDESServer4J/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES server</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/ldio/ldio-inputs/ldio-ldes-client"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES client</span> </button> </a> <a href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/blog"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Blog posts</span> </button> </a> <a href="https://informatievlaanderen.github.io/OSLO-mapping/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">OSLO mapping</span> </button> </a> </div> </div> </div> <style> #help-needed[data-v-df634f57] { display: flex; align-items: center; gap: 5px; background-image: url(https://informatievlaanderen.github.io/OSLO-mapping/assets/images/hulp_nodig.svg); width: 144px; height: 44px; } .custom-border-activated { background-color: rgb(255, 230, 21); } .custom-border { border: 0.3px solid rgb(0, 200, 171); /* Randkleur */ /* Voeg hier eventueel andere stijlelementen toe */ } .navbar-fixed-top .navbar-inner { margin-top:30px; height: 35px; padding: 0; border-top: 1px solid #d4d4d4; z-index: 1000; position: fixed; right:0px; } @media (min-width: 50rem) .navbar-fixed-top { position: relative !important; width: auto !important; height: 100% !important; padding: 0; transition: none; } .global-header[data-v-df634f57] { display: flex; margin-left: 0px; align-items: center; position: fixed; width: 100%; background-color: white; z-index: 100; } .test-header{ margin-bottom: 20px; overflow:hidden; z-index: 100; } element.style { } .small-global-header-divider[data-v-df634f57] { margin: 0 8px 0 4px; } .header-font { color: #333332; font-family: Flanders Art Sans, sans-serif; font-size: 12px; font-style: normal; font-weight: 500; line-height: normal; letter-spacing: 0.5px; text-transform: uppercase; } .spacer { flex-grow: 1; } .divider { border: 1px solid #8f8f8f66; margin: 0; } #help-needed > span[data-v-df634f57] { margin-left: 25px; } /* title of the site */ #header { height: 80px; } #header hgroup { position: absolute; top: 10px; left: 20px; } #header h1 { margin: 0; font-size: 1.75em; font-weight: bold; } #header h2 { color: #ccc; margin: 0 0 4px 16px; line-height: 0.8; font-size: 1.0em; font-weight: normal; } #header a, #header a:hover, #header a:visited { text-decoration: none; } .navbar .nav > .active > a, .navbar .nav > .active > a:hover, .navbar .nav > .active > a:focus { box-shadow: none; } .navbar .btn-navbar { margin-bottom: 5px; } </style> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Onboarding tutorial </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Onboarding tutorial</a></li></ul> <div class="nav-category">Publishing an LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/publishing/publishing_protected_LDES" class="nav-list-link">Publishing a protected LDES</a></li><li class="nav-list-item"><a href="/publishing/basic_setup" class="nav-list-link">Basic setup</a></li><li class="nav-list-item active"><a href="/publishing/minimal_server" class="nav-list-link active">Minimal Server</a></li></ul> <div class="nav-category">Data pipeline</div> <ul class="nav-list"><li class="nav-list-item"><a href="/pipeline/minimal_workbench" class="nav-list-link">Minimal workbench</a></li><li class="nav-list-item"><a href="/pipeline/advanced_conversion" class="nav-list-link">Advanced conversion</a></li></ul> <div class="nav-category">Consuming an LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/consuming/consuming" class="nav-list-link">Setup a minimal LDES client</a></li></ul> <div class="nav-category">Protected LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/protected/publishing_protected_LDES" class="nav-list-link">Publishing a protected LDES</a></li></ul> </nav> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Onboarding tutorial" aria-label="Search Onboarding tutorial" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="setting-up-a-minimal-ldes-server"> <a href="#setting-up-a-minimal-ldes-server" class="anchor-heading" aria-labelledby="setting-up-a-minimal-ldes-server"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Setting Up a Minimal LDES Server </h1> <p>This quick start guide will show you how to setup a minimal LDES server to accept linked data members.</p> <p>Please see the <a href="../README.md">introduction</a> for the example data set and pre-requisites, as well as an overview of all examples.</p> <h2 id="enter-the-ldes-server"> <a href="#enter-the-ldes-server" class="anchor-heading" aria-labelledby="enter-the-ldes-server"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Enter the LDES Server </h2> <p>The <a href="https://informatievlaanderen.github.io/VSDS-LDESServer4J/">LDES Server</a> is one of the components built as part of a large project on creating a <a href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal">data space for Flanders</a> (sorry, Dutch only) for Data Owners, Data Publishers and Data Clients. Its main purpose is to accept data set members, store them in external storage and allow to retrieve the data set as a LDES for replication as a whole or just a subset of the data set. However, the real benefit of LDES lies in its ability to allow Data Clients to keep in sync with changes that occur on the data set.</p> <p>Data Clients are typically not only interested in the current state of a data set but also in the historical changes that occurred, e.g. in order to understand the evolution of air quality in a city you need the analyze the measurements of some sensors over time. The LDES Server expects the data that it receives to be a so called version object, that is, the state of something at some point in time. This allows you to retrieve the changes of the object state from initial state (first version) to the current state (latest version) and due to the ability to keep in sync, even the future state (future versions). Pretty cool! Don’t you think?</p> <h2 id="where-do-we-keep-this-gem"> <a href="#where-do-we-keep-this-gem" class="anchor-heading" aria-labelledby="where-do-we-keep-this-gem"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Where Do We Keep This Gem? </h2> <p>As each Data Publisher needs to publish its own data set, the LDES Server is offered as a Docker image that can be configured to get the job done in a custom way and according to the needs of the Data Publisher.</p> <p>The Docker images are available on <a href="https://hub.docker.com/r/ldes/ldes-server">Docker Hub</a>. <a href="https://hub.docker.com/r/ldes/ldes-server/tags">Here</a> you can find the stable releases. Notice that some tags end with <code class="language-plaintext highlighter-rouge">-SNAPSHOT</code>. These images can safely be used. The only difference with the ones without this label is that validity with the official specification did not yet occur. Functionality, they are exactly the same. Every two weeks (our sprint duration) a new images is created and labeled with <a href="https://semver.org/">semantic versioning</a>. You can expect backwards compatible images to keep the same major version number and have an increased minor version number. Very occasionally we create a patch release with a non-zero patch number.</p> <blockquote> <p><strong>Note</strong> that our <a href="https://github.com/Informatievlaanderen/VSDS-LDESServer4J">Github repository</a> contains many <a href="https://github.com/Informatievlaanderen/VSDS-LDESServer4J/pkgs/container/ldes-server">more images</a> which are created of our development branch. Please use these only if really needed as they can and will contain some issues.</p> </blockquote> <h2 id="setup-up-the-basics"> <a href="#setup-up-the-basics" class="anchor-heading" aria-labelledby="setup-up-the-basics"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Setup Up the Basics </h2> <p>As mentioned in the pre-requisites, you need some minimal knowledge on Docker Compose as we use it to run both the LDES Server and the required data storage system as a container. Currently we only support <a href="https://www.mongodb.com/">MongoDB</a> for storing the LDES members and other data. On <a href="https://hub.docker.com/_/mongo">Docker Hub</a> you can found the <a href="https://hub.docker.com/_/mongo/tags">container images</a>. Depending on your host hardware (e.g. a Raspberry Pi) you may need an older version, otherwise feel free to use the latest. Some other MongoDB compatible (cloud) databases can also be used (e.g. <a href="https://learn.microsoft.com/en-us/azure/cosmos-db/">CosmosDB</a> and <a href="https://aws.amazon.com/documentdb/">DocumentDB</a>). In the future we may add other databases.</p> <p>If you look into the <a href="./docker-compose.yml">Docker Compose file</a>, you will see that we define one (private) network for our two services: the LDES Server and the MongoDB. This allows the LDES Server to refer to the MongoDB by its service name <code class="language-plaintext highlighter-rouge">ldes-mongodb</code> but also requires us to map the internal port numbers (respectively 8080 and 27017) to external port numbers (respectively 9003 and 27017) in order to be able to reach the services (respectively <code class="language-plaintext highlighter-rouge">http://localhost:9003</code> and <code class="language-plaintext highlighter-rouge">mongodb://localhost:27017</code>, or even <code class="language-plaintext highlighter-rouge">mongodb://locahost</code>). We’ll see in a minute where the internal ports come from. Furthermore the compose file contains names for our containers, the images and tags to use as a definition (i.e. a cookie-cutter) for our containers, a dependency on the MongoDB so the LDES Server is started after the database container, and finally a (read-only) volume mapping of our LDES Server configuration file into the container file-system to allow our LDES Server to use it.</p> <p>The LDES Server <a href="./config/application.yml">configuration file</a> is pretty straight-forward as well. It contains the <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a> (<code class="language-plaintext highlighter-rouge">spring.data.mongodb.uri</code>), basically the database connection string, of our MongoDB database. Note that the format is <code class="language-plaintext highlighter-rouge">&lt;scheme&gt;://&lt;server&gt;:&lt;port&gt;/&lt;database&gt;</code> where the <code class="language-plaintext highlighter-rouge">&lt;scheme&gt;</code> is always <code class="language-plaintext highlighter-rouge">mongodb</code>, the <code class="language-plaintext highlighter-rouge">&lt;server&gt;</code> is the service name in the composer file (i.e. <code class="language-plaintext highlighter-rouge">ldes-mongodb</code>), the <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> is the default port number <code class="language-plaintext highlighter-rouge">27017</code> and has been omitted, and finally, <code class="language-plaintext highlighter-rouge">&lt;database&gt;</code> is the name of the database that will hold our LDES data, for which we chose <code class="language-plaintext highlighter-rouge">minimal-server</code>. In addition, we need to specify that our LDES Server uses the MongoDB driver to automatically create the necessary indexes (even on CosmosDB!). We also need to specify the external base path of our LDES Server so that the links within the LDES can be followed. Because we do port mapping in the compose file, we set our LDES Server to be available at http://localhost:9003 in this tutorial. But not yet, we first need to start our containers. Ready for some action? Let’s get our hands dirty!</p> <h2 id="systems-ready-3-2-1--ignition"> <a href="#systems-ready-3-2-1--ignition" class="anchor-heading" aria-labelledby="systems-ready-3-2-1--ignition"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Systems Ready? 3, 2, 1 .. Ignition! </h2> <p>Well, enough theory! Let’s get this thing going and see how we can actually feed the LDES Server with some data.</p> <p>To run the commands below you need to use a <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash command shell</a>. This allows us to keep the commands the same across the main three operating systems: Linux, Windows and MacOS. But, if you cloned this repository locally you already have a bash shell! It comes with your git installation.</p> <p>To launch the LDES Server and the MongoDB containers:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldes-server$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div> <blockquote> <p><strong>Note</strong> that we start the containers as deamons and then wait for the LDES server to be available by checking every second that the container log file contains the magic string <code class="language-plaintext highlighter-rouge">Started Application in</code>. You could also simply start it with <code class="language-plaintext highlighter-rouge">docker compose up</code> and wait until you actually see this magic string, but then you need to open a new command shell to execute the commands in the next sections.</p> </blockquote> <h2 id="defining-our-first-ldes"> <a href="#defining-our-first-ldes" class="anchor-heading" aria-labelledby="defining-our-first-ldes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Defining Our First LDES </h2> <p>As soon as the systems are started and ready we need to tell our LDES Server what data set we want to store because the LDES Server can host more than one data set. To manage this the LDES Server offers an administration API. We will explore this API later but for now we simply send the <a href="./definitions/occupancy.ttl">LDES definition</a> to this API so that we can store <a href="./data/member.ttl">some data</a> in our data set.</p> <p>To define the LDES:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/admin/api/v1/eventstreams"</span> <span class="nt">-d</span> <span class="s2">"@./definitions/occupancy.ttl"</span>
</code></pre></div></div> <p>This may look like a bit of hocus-pocus but it is truly very simple. The <a href="./definitions/occupancy.ttl">LDES definition</a> is a <a href="https://www.w3.org/TR/turtle/">turtle file</a> which is a way of serializing <a href="https://www.w3.org/RDF/">RDF</a>. The definition file starts with a few declarations allowing for some short-hand notation so we do not get lost in translation. The other lines are the interesting part. First we start by saying that we define a LDES (<code class="language-plaintext highlighter-rouge">&lt;/occupancy&gt; a ldes:EventStream</code>) and that we want the server to accept members and fetching the LDES on a sub-path (<code class="language-plaintext highlighter-rouge">/occupancy</code>). Then, we tell it what type our members will be (<code class="language-plaintext highlighter-rouge">sh:targetClass :offStreetParkingGround</code>, or <code class="language-plaintext highlighter-rouge">http://www.w3.org/ns/shacl#targetClass https://example.org/ns/mobility#offStreetParkingGround</code> in full). Finally, we tell it that these members are version objects of the state object identified by the member property <code class="language-plaintext highlighter-rouge">dcterms:isVersionOf</code> and can be distinguised by the member property <code class="language-plaintext highlighter-rouge">prov:generatedAtTime</code>. Essentially, these properties allow us to group members to find all versions of something respectively to order them to know which member precedes another member.</p> <p>We can verify that the LDES is actually known to the server by requesting it by its endpoint. This endpoint depends on several things: the port mapping, the base path of the server and the data set sub-path we defined in the LDES definition. In this example it is <code class="language-plaintext highlighter-rouge">http://localhost:9003/occupancy</code>.</p> <p>To check out our LDES:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:9003/occupancy
</code></pre></div></div> <h2 id="storing-our-first-member"> <a href="#storing-our-first-member" class="anchor-heading" aria-labelledby="storing-our-first-member"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Storing Our First Member </h2> <p>Once we have defined our LDES we can finally send our first member to the endpoint we defined and the LDES Server can store it.</p> <p>To ingest a member:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/occupancy"</span> <span class="nt">-d</span> <span class="s2">"@./data/member.ttl"</span>
</code></pre></div></div> <blockquote> <p><strong>Note</strong> that the member is some linked data serialized as a turtle file for which the default file extension is <code class="language-plaintext highlighter-rouge">.ttl</code> and the mime type is <code class="language-plaintext highlighter-rouge">text/turtle</code>. The LDES server can accept a few more RDF serialization formats, each identified by their own mime type.</p> </blockquote> <h2 id="creating-our-first-view"> <a href="#creating-our-first-view" class="anchor-heading" aria-labelledby="creating-our-first-view"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Creating Our First View </h2> <p>Now that we have ingested a member, you may wonder how we can check that it is actually in there? And how will Data Clients retrieve our small data set. The LDES Server can offer various views on each data set so we need to tell it how we want the LDES to be available for consumption. We do this again using the administration API by sending a <a href="./definitions/occupancy.by-page.ttl">view definition</a> to the LDES Server and attaching it to our LDES. The LDES Server will start a background process to create this LDES view and offer the data set in fragments. Such a fragment is a number of members as well as information about the LDES and ways to navigate to the other members from the data set. See the <a href="https://treecg.github.io/specification/">Tree specification</a> on which the LDES specification is built for details. Essentially, the fragments create a (typically hierarchical but possibly a graph) structure for navigating between them by defining the relation between themselves and their related fragments. Data Clients can then navigate to all or a part of these relations and therefore reach all or a subset of the data set. But enough theory! Let’s define the view and request the member.</p> <p>To define the LDES view:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"content-type: text/turtle"</span> <span class="s2">"http://localhost:9003/admin/api/v1/eventstreams/occupancy/views"</span> <span class="nt">-d</span> <span class="s2">"@./definitions/occupancy.by-page.ttl"</span>
</code></pre></div></div> <p>The view definition is a turtle file very similar to the LDES definition. It contains the view definition (it is a tree node) and how to get to this view (<code class="language-plaintext highlighter-rouge">&lt;/occupancy/by-page&gt; a tree:Node</code>). It set the number of members per fragment (<code class="language-plaintext highlighter-rouge">tree:pageSize "50"^^xsd:integer</code>). That’s all folks!</p> <p>To check out our LDES:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:9003/occupancy/by-page
</code></pre></div></div> <blockquote> <p><strong>Note</strong> that you can create more than one view of a LDES, even for simple pagination by specifying a different view URI and page size. Later when we learn about retention policies and different fragmentation strategies, this may make more sense. For now remember that you can create a view before or after you ingest data, You can delete views and re-create them with different options. For this, you will need to use the administration API. Later, we will show you how to enable the <a href="https://swagger.io/">swagger</a> to explore this API.</p> </blockquote> <h2 id="show-me-the-data"> <a href="#show-me-the-data" class="anchor-heading" aria-labelledby="show-me-the-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Show Me the Data! </h2> <p>Depending on the size of the data set the LDES Server magic may take a while to make all members available, but you can already get the first members almost immediately.</p> <p>To retrieve the data set:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:9003/occupancy/by-page?pageNumber<span class="o">=</span>1
</code></pre></div></div> <h2 id="all-good-things-must-come-to-an-end"> <a href="#all-good-things-must-come-to-an-end" class="anchor-heading" aria-labelledby="all-good-things-must-come-to-an-end"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> All Good Things Must Come To an End </h2> <p>That’s it. Now you have an understanding what the LDES Server is about, where you can find it and how to set it up. You have learned how to create a LDES and a view for it as well as how to ingest and retrieve your data set. It’s time now to stop the LDES Server and its storage.</p> <p>To bring the containers down and remove the private network:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose down
</code></pre></div></div> </main> <hr> <footer> <p class="text-small text-grey-dk-100 mb-0"></p> <div class="d-flex mt-2"> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
