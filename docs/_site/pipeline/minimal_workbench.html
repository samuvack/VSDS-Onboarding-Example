<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Minimal workbench | Onboarding tutorial</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="Minimal workbench" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Setting Up a Minimal LDIO Workbench This quick start guide will show you how to setup a minimal workbench to create version objects from state objects. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Show Me Your Workbench The LDES Server allows to ingest version objects but typically the source data represents the state of an object and not a version in time of this state. That is why a data transformation is needed to create such a version object. Such a data transformation can be standalone or as part of a data transformation pipeline which can be build in various ways with many different data processing systems. One such a workbench that allows to create data pipelines is Apache NiFi. This is a mature and solid open-source solution that comes with many features, allows for horizontal scaling and comes with many standard processors for creating and monitoring complex data pipelines. However, it also comes with a steep learning curve and some other drawbacks. The Linked Data Interactions Orchestrator (LDIO is a simple and more light-weight solution that eases the process of creating more straightforward, linear data transformations while requiring minimal resources and attempting to keep the learning curve as low as possible. It is by no means a silver bullet but experience has learned us that most data publishing use cases can easy be covered with a simple linear pipeline and as such LDIO usually suffies. LDIO allows to create one or more synchronous linear pipelines that convert linked and non-linked data to version objects that can be ingested by an LDES Server. It is centered around the concept of one input source with an adaptor to convert to linked data, one or more in-memory transformation steps and sending the result to one or more output sinks. Various input components are available for starting a pipeline such as: accepting HTTP messages both using a push model (HTTP listener) and a pull model (HTTP poller), reading from Kafka, etc. If the source data is already linked data you can use a simple RDF adaptor which allows to parse various RDF serializations. If the source data is not yet linked data you can use either a JSON-LD adaptor to attach a JSON-LD context to a JSON message or alternatively a RML adaptor, which allows to create linked data from various other message formats, such as JSON, XML, CSV, etc. On the output side we also provide several possibilities such as POST-ing using HTTP, writing to Kafka, etc. We provide several transformation components for manipulating linked data but most data transformations can be done using a SPARQL construct transformation step. In addition, we also provide some components for more specific tasks such as enriching the data from some external HTTP source, converting GeoJson to Well Known Text (WKT), etc. All these components are provided as part of the LDIO workbench which is packaged as a Docker image. The Docker images are available on Docker Hub. The stable releases can be found here. Configure Your First Pipeline The example docker compose file only contains a LDIO service which runs in a private network and uses volume mapping to have its configuration file available in the container. As we will see in a minute, the pipeline starts with a HTTP listener and therefore we need a port mapping to allow the workbench to receive HTTP messages. The workbench configuration file starts with specifying the port on which the HTTP listener will accept requests. We have used the default port number 8080 and could have easily omitted it from te configuration. Other than that, we only need to specify the actual pipeline definition. Note that the workbench can contain more than one pipeline if needed. The pipeline definition starts with a name and a description. The latter is purely for documentation purposes, but the former is used as the base path on which the HTTP listener receives requests. In our case this is (based on the docker compose port mapping): http://localhost:9004/p+r-pipeline. After that the definition continues with the input component and associated adapter, the transformation steps and the output(s). Let’s look at these in more detail. The input component simply states that it is a HTTP listener which uses a RDF adaptor and as such is expecting Linked Data: input: name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioHttpIn adapter: name: be.vlaanderen.informatievlaanderen.ldes.ldi.RdfAdapter We need a transformation step to turn the linked data state object which we receive into a version object. We need to specify for which object type we need to change it to a version object. We use this type to retrieve that object’s identifier and create the version object ID based on this identifier concatenated with the delimiter and the value of the date-observed-property. We also use the identifier to add a property as specified by versionOf-property to the version object. Finally, we also use the date-observed-property value to add a property as defined by the generatedAt-property to the version object. This sounds way more complicated than it actually is as we will show later. transformers: - name: be.vlaanderen.informatievlaanderen.ldes.ldi.VersionObjectCreator config: member-type: https://example.org/ns/mobility#offStreetParkingGround delimiter: &quot;/&quot; date-observed-property: &lt;http://www.w3.org/ns/prov#generatedAtTime&gt; generatedAt-property: http://www.w3.org/ns/prov#generatedAtTime versionOf-property: http://purl.org/dc/terms/isVersionOf Note that we used the http://www.w3.org/ns/prov#generatedAtTime property for both creating the version object ID as well as for the generatedAt-property. This will prevent creating another property with the same date/time value. Finally, the version object is output to the specified sink. For demo purposes we use a component that simply logs the member to the console, which for a Docker container results in its logs. outputs: - name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioConsoleOut Launch the Magic After this long introduction let’s get our hands dirty and see the magic in action. To start the workbench and wait until it is available: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldio-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done There is no visual component yet for the LDIO workbench, but you can check its status at http://localhost:9004/actuator/health. You’ve Got Mail Now that the workbench is up and running we can send a message through the pipeline and see its version object outputted to the workbench logs. We use the following simple JSON-LD message (clipped to the relevant parts): { &quot;@context&quot;: { &quot;@vocab&quot;: &quot;https://example.org/ns/mobility#&quot;, &quot;urllinkaddress&quot;: &quot;@id&quot;, &quot;type&quot;: &quot;@type&quot;, &quot;lastupdate&quot;: { &quot;@id&quot;: &quot;http://www.w3.org/ns/prov#generatedAtTime&quot;, &quot;@type&quot;: &quot;http://www.w3.org/2001/XMLSchema#dateTime&quot; } }, &quot;lastupdate&quot;: &quot;2023-11-30T21:45:15+01:00&quot;, &quot;type&quot;: &quot;offStreetParkingGround&quot;, &quot;urllinkaddress&quot;: &quot;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal&quot;, ... } Note: do not worry if you do not understand every detail in the context part. Its main purpose is to add meaning to the state object properties. To send the message into the pipeline: curl -X POST -H &quot;Content-Type: application/ld+json&quot; &quot;http://localhost:9004/p+r-pipeline&quot; -d &quot;@./data/message.jsonld&quot; Since it is a small and straight forward message the workbench log will almost immediately contain the version object. To watch the version object appear in the workbench log docker logs -n 30 $(docker ps -q -f &quot;name=ldio-workbench$&quot;) You should see the following (clipped to the relevant parts): @prefix mobility: &lt;https://example.org/ns/mobility#&gt; . @prefix park-and-ride-pr: &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/&gt; . @prefix prov: &lt;http://www.w3.org/ns/prov#&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00&gt; rdf:type mobility:offStreetParkingGround ; terms:isVersionOf park-and-ride-pr:pr-gentbrugge-arsenaal ; prov:generatedAtTime &quot;2023-11-30T21:45:15+01:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; ; ... If you compare the generated member in the container log with the example that we process, you will notice that the state object ID (park-and-ride-pr:pr-gentbrugge-arsenaal or http://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal in full) is a property (terms:isVersionOf or http://purl.org/dc/terms/isVersionOf in full) of the version object and the version ID (https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00) is a combination of that state object ID, the delimiter (/) and the prov:generatedAtTime property (2023-11-30T21:45:15+01:00). That’s All Folks You now know how to configure a basic LDIO workbench which takes in RDF messages containing a single state object and turn it into a version object that can be ingested as a LDES member. To bring the containers down and remove the private network: docker compose down" /> <meta property="og:description" content="Setting Up a Minimal LDIO Workbench This quick start guide will show you how to setup a minimal workbench to create version objects from state objects. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Show Me Your Workbench The LDES Server allows to ingest version objects but typically the source data represents the state of an object and not a version in time of this state. That is why a data transformation is needed to create such a version object. Such a data transformation can be standalone or as part of a data transformation pipeline which can be build in various ways with many different data processing systems. One such a workbench that allows to create data pipelines is Apache NiFi. This is a mature and solid open-source solution that comes with many features, allows for horizontal scaling and comes with many standard processors for creating and monitoring complex data pipelines. However, it also comes with a steep learning curve and some other drawbacks. The Linked Data Interactions Orchestrator (LDIO is a simple and more light-weight solution that eases the process of creating more straightforward, linear data transformations while requiring minimal resources and attempting to keep the learning curve as low as possible. It is by no means a silver bullet but experience has learned us that most data publishing use cases can easy be covered with a simple linear pipeline and as such LDIO usually suffies. LDIO allows to create one or more synchronous linear pipelines that convert linked and non-linked data to version objects that can be ingested by an LDES Server. It is centered around the concept of one input source with an adaptor to convert to linked data, one or more in-memory transformation steps and sending the result to one or more output sinks. Various input components are available for starting a pipeline such as: accepting HTTP messages both using a push model (HTTP listener) and a pull model (HTTP poller), reading from Kafka, etc. If the source data is already linked data you can use a simple RDF adaptor which allows to parse various RDF serializations. If the source data is not yet linked data you can use either a JSON-LD adaptor to attach a JSON-LD context to a JSON message or alternatively a RML adaptor, which allows to create linked data from various other message formats, such as JSON, XML, CSV, etc. On the output side we also provide several possibilities such as POST-ing using HTTP, writing to Kafka, etc. We provide several transformation components for manipulating linked data but most data transformations can be done using a SPARQL construct transformation step. In addition, we also provide some components for more specific tasks such as enriching the data from some external HTTP source, converting GeoJson to Well Known Text (WKT), etc. All these components are provided as part of the LDIO workbench which is packaged as a Docker image. The Docker images are available on Docker Hub. The stable releases can be found here. Configure Your First Pipeline The example docker compose file only contains a LDIO service which runs in a private network and uses volume mapping to have its configuration file available in the container. As we will see in a minute, the pipeline starts with a HTTP listener and therefore we need a port mapping to allow the workbench to receive HTTP messages. The workbench configuration file starts with specifying the port on which the HTTP listener will accept requests. We have used the default port number 8080 and could have easily omitted it from te configuration. Other than that, we only need to specify the actual pipeline definition. Note that the workbench can contain more than one pipeline if needed. The pipeline definition starts with a name and a description. The latter is purely for documentation purposes, but the former is used as the base path on which the HTTP listener receives requests. In our case this is (based on the docker compose port mapping): http://localhost:9004/p+r-pipeline. After that the definition continues with the input component and associated adapter, the transformation steps and the output(s). Let’s look at these in more detail. The input component simply states that it is a HTTP listener which uses a RDF adaptor and as such is expecting Linked Data: input: name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioHttpIn adapter: name: be.vlaanderen.informatievlaanderen.ldes.ldi.RdfAdapter We need a transformation step to turn the linked data state object which we receive into a version object. We need to specify for which object type we need to change it to a version object. We use this type to retrieve that object’s identifier and create the version object ID based on this identifier concatenated with the delimiter and the value of the date-observed-property. We also use the identifier to add a property as specified by versionOf-property to the version object. Finally, we also use the date-observed-property value to add a property as defined by the generatedAt-property to the version object. This sounds way more complicated than it actually is as we will show later. transformers: - name: be.vlaanderen.informatievlaanderen.ldes.ldi.VersionObjectCreator config: member-type: https://example.org/ns/mobility#offStreetParkingGround delimiter: &quot;/&quot; date-observed-property: &lt;http://www.w3.org/ns/prov#generatedAtTime&gt; generatedAt-property: http://www.w3.org/ns/prov#generatedAtTime versionOf-property: http://purl.org/dc/terms/isVersionOf Note that we used the http://www.w3.org/ns/prov#generatedAtTime property for both creating the version object ID as well as for the generatedAt-property. This will prevent creating another property with the same date/time value. Finally, the version object is output to the specified sink. For demo purposes we use a component that simply logs the member to the console, which for a Docker container results in its logs. outputs: - name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioConsoleOut Launch the Magic After this long introduction let’s get our hands dirty and see the magic in action. To start the workbench and wait until it is available: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldio-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done There is no visual component yet for the LDIO workbench, but you can check its status at http://localhost:9004/actuator/health. You’ve Got Mail Now that the workbench is up and running we can send a message through the pipeline and see its version object outputted to the workbench logs. We use the following simple JSON-LD message (clipped to the relevant parts): { &quot;@context&quot;: { &quot;@vocab&quot;: &quot;https://example.org/ns/mobility#&quot;, &quot;urllinkaddress&quot;: &quot;@id&quot;, &quot;type&quot;: &quot;@type&quot;, &quot;lastupdate&quot;: { &quot;@id&quot;: &quot;http://www.w3.org/ns/prov#generatedAtTime&quot;, &quot;@type&quot;: &quot;http://www.w3.org/2001/XMLSchema#dateTime&quot; } }, &quot;lastupdate&quot;: &quot;2023-11-30T21:45:15+01:00&quot;, &quot;type&quot;: &quot;offStreetParkingGround&quot;, &quot;urllinkaddress&quot;: &quot;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal&quot;, ... } Note: do not worry if you do not understand every detail in the context part. Its main purpose is to add meaning to the state object properties. To send the message into the pipeline: curl -X POST -H &quot;Content-Type: application/ld+json&quot; &quot;http://localhost:9004/p+r-pipeline&quot; -d &quot;@./data/message.jsonld&quot; Since it is a small and straight forward message the workbench log will almost immediately contain the version object. To watch the version object appear in the workbench log docker logs -n 30 $(docker ps -q -f &quot;name=ldio-workbench$&quot;) You should see the following (clipped to the relevant parts): @prefix mobility: &lt;https://example.org/ns/mobility#&gt; . @prefix park-and-ride-pr: &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/&gt; . @prefix prov: &lt;http://www.w3.org/ns/prov#&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00&gt; rdf:type mobility:offStreetParkingGround ; terms:isVersionOf park-and-ride-pr:pr-gentbrugge-arsenaal ; prov:generatedAtTime &quot;2023-11-30T21:45:15+01:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; ; ... If you compare the generated member in the container log with the example that we process, you will notice that the state object ID (park-and-ride-pr:pr-gentbrugge-arsenaal or http://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal in full) is a property (terms:isVersionOf or http://purl.org/dc/terms/isVersionOf in full) of the version object and the version ID (https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00) is a combination of that state object ID, the delimiter (/) and the prov:generatedAtTime property (2023-11-30T21:45:15+01:00). That’s All Folks You now know how to configure a basic LDIO workbench which takes in RDF messages containing a single state object and turn it into a version object that can be ingested as a LDES member. To bring the containers down and remove the private network: docker compose down" /> <link rel="canonical" href="http://localhost:4000/pipeline/minimal_workbench" /> <meta property="og:url" content="http://localhost:4000/pipeline/minimal_workbench" /> <meta property="og:site_name" content="Onboarding tutorial" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-02-19T11:01:58+01:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Minimal workbench" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-19T11:01:58+01:00","datePublished":"2024-02-19T11:01:58+01:00","description":"Setting Up a Minimal LDIO Workbench This quick start guide will show you how to setup a minimal workbench to create version objects from state objects. Please see the introduction for the example data set and pre-requisites, as well as an overview of all examples. Show Me Your Workbench The LDES Server allows to ingest version objects but typically the source data represents the state of an object and not a version in time of this state. That is why a data transformation is needed to create such a version object. Such a data transformation can be standalone or as part of a data transformation pipeline which can be build in various ways with many different data processing systems. One such a workbench that allows to create data pipelines is Apache NiFi. This is a mature and solid open-source solution that comes with many features, allows for horizontal scaling and comes with many standard processors for creating and monitoring complex data pipelines. However, it also comes with a steep learning curve and some other drawbacks. The Linked Data Interactions Orchestrator (LDIO is a simple and more light-weight solution that eases the process of creating more straightforward, linear data transformations while requiring minimal resources and attempting to keep the learning curve as low as possible. It is by no means a silver bullet but experience has learned us that most data publishing use cases can easy be covered with a simple linear pipeline and as such LDIO usually suffies. LDIO allows to create one or more synchronous linear pipelines that convert linked and non-linked data to version objects that can be ingested by an LDES Server. It is centered around the concept of one input source with an adaptor to convert to linked data, one or more in-memory transformation steps and sending the result to one or more output sinks. Various input components are available for starting a pipeline such as: accepting HTTP messages both using a push model (HTTP listener) and a pull model (HTTP poller), reading from Kafka, etc. If the source data is already linked data you can use a simple RDF adaptor which allows to parse various RDF serializations. If the source data is not yet linked data you can use either a JSON-LD adaptor to attach a JSON-LD context to a JSON message or alternatively a RML adaptor, which allows to create linked data from various other message formats, such as JSON, XML, CSV, etc. On the output side we also provide several possibilities such as POST-ing using HTTP, writing to Kafka, etc. We provide several transformation components for manipulating linked data but most data transformations can be done using a SPARQL construct transformation step. In addition, we also provide some components for more specific tasks such as enriching the data from some external HTTP source, converting GeoJson to Well Known Text (WKT), etc. All these components are provided as part of the LDIO workbench which is packaged as a Docker image. The Docker images are available on Docker Hub. The stable releases can be found here. Configure Your First Pipeline The example docker compose file only contains a LDIO service which runs in a private network and uses volume mapping to have its configuration file available in the container. As we will see in a minute, the pipeline starts with a HTTP listener and therefore we need a port mapping to allow the workbench to receive HTTP messages. The workbench configuration file starts with specifying the port on which the HTTP listener will accept requests. We have used the default port number 8080 and could have easily omitted it from te configuration. Other than that, we only need to specify the actual pipeline definition. Note that the workbench can contain more than one pipeline if needed. The pipeline definition starts with a name and a description. The latter is purely for documentation purposes, but the former is used as the base path on which the HTTP listener receives requests. In our case this is (based on the docker compose port mapping): http://localhost:9004/p+r-pipeline. After that the definition continues with the input component and associated adapter, the transformation steps and the output(s). Let’s look at these in more detail. The input component simply states that it is a HTTP listener which uses a RDF adaptor and as such is expecting Linked Data: input: name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioHttpIn adapter: name: be.vlaanderen.informatievlaanderen.ldes.ldi.RdfAdapter We need a transformation step to turn the linked data state object which we receive into a version object. We need to specify for which object type we need to change it to a version object. We use this type to retrieve that object’s identifier and create the version object ID based on this identifier concatenated with the delimiter and the value of the date-observed-property. We also use the identifier to add a property as specified by versionOf-property to the version object. Finally, we also use the date-observed-property value to add a property as defined by the generatedAt-property to the version object. This sounds way more complicated than it actually is as we will show later. transformers: - name: be.vlaanderen.informatievlaanderen.ldes.ldi.VersionObjectCreator config: member-type: https://example.org/ns/mobility#offStreetParkingGround delimiter: &quot;/&quot; date-observed-property: &lt;http://www.w3.org/ns/prov#generatedAtTime&gt; generatedAt-property: http://www.w3.org/ns/prov#generatedAtTime versionOf-property: http://purl.org/dc/terms/isVersionOf Note that we used the http://www.w3.org/ns/prov#generatedAtTime property for both creating the version object ID as well as for the generatedAt-property. This will prevent creating another property with the same date/time value. Finally, the version object is output to the specified sink. For demo purposes we use a component that simply logs the member to the console, which for a Docker container results in its logs. outputs: - name: be.vlaanderen.informatievlaanderen.ldes.ldio.LdioConsoleOut Launch the Magic After this long introduction let’s get our hands dirty and see the magic in action. To start the workbench and wait until it is available: docker compose up -d while ! docker logs $(docker ps -q -f &quot;name=ldio-workbench$&quot;) 2&gt; /dev/null | grep &#39;Started Application in&#39; ; do sleep 1; done There is no visual component yet for the LDIO workbench, but you can check its status at http://localhost:9004/actuator/health. You’ve Got Mail Now that the workbench is up and running we can send a message through the pipeline and see its version object outputted to the workbench logs. We use the following simple JSON-LD message (clipped to the relevant parts): { &quot;@context&quot;: { &quot;@vocab&quot;: &quot;https://example.org/ns/mobility#&quot;, &quot;urllinkaddress&quot;: &quot;@id&quot;, &quot;type&quot;: &quot;@type&quot;, &quot;lastupdate&quot;: { &quot;@id&quot;: &quot;http://www.w3.org/ns/prov#generatedAtTime&quot;, &quot;@type&quot;: &quot;http://www.w3.org/2001/XMLSchema#dateTime&quot; } }, &quot;lastupdate&quot;: &quot;2023-11-30T21:45:15+01:00&quot;, &quot;type&quot;: &quot;offStreetParkingGround&quot;, &quot;urllinkaddress&quot;: &quot;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal&quot;, ... } Note: do not worry if you do not understand every detail in the context part. Its main purpose is to add meaning to the state object properties. To send the message into the pipeline: curl -X POST -H &quot;Content-Type: application/ld+json&quot; &quot;http://localhost:9004/p+r-pipeline&quot; -d &quot;@./data/message.jsonld&quot; Since it is a small and straight forward message the workbench log will almost immediately contain the version object. To watch the version object appear in the workbench log docker logs -n 30 $(docker ps -q -f &quot;name=ldio-workbench$&quot;) You should see the following (clipped to the relevant parts): @prefix mobility: &lt;https://example.org/ns/mobility#&gt; . @prefix park-and-ride-pr: &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/&gt; . @prefix prov: &lt;http://www.w3.org/ns/prov#&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . @prefix terms: &lt;http://purl.org/dc/terms/&gt; . &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00&gt; rdf:type mobility:offStreetParkingGround ; terms:isVersionOf park-and-ride-pr:pr-gentbrugge-arsenaal ; prov:generatedAtTime &quot;2023-11-30T21:45:15+01:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; ; ... If you compare the generated member in the container log with the example that we process, you will notice that the state object ID (park-and-ride-pr:pr-gentbrugge-arsenaal or http://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal in full) is a property (terms:isVersionOf or http://purl.org/dc/terms/isVersionOf in full) of the version object and the version ID (https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00) is a combination of that state object ID, the delimiter (/) and the prov:generatedAtTime property (2023-11-30T21:45:15+01:00). That’s All Folks You now know how to configure a basic LDIO workbench which takes in RDF messages containing a single state object and turn it into a version object that can be ingested as a LDES member. To bring the containers down and remove the private network: docker compose down","headline":"Minimal workbench","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/pipeline/minimal_workbench"},"url":"http://localhost:4000/pipeline/minimal_workbench"}</script> <!-- End Jekyll SEO tag --> <div class="test-header" data-v-df634f57="" data-v-7a7a37b1=""> <div class="global-header" data-v-df634f57=""><img src="/assets/images/LOGO_Vlaanderen_NIV2.svg" alt="Vlaanderen" data-v-df634f57=""><img class="small-global-header-divider" src="/assets/images/divider_globalheader.svg" alt="divider" data-v-df634f57=""><span class="header-title header-font" data-v-df634f57="">Vlaamse Smart Data Space</span><span class="spacer" data-v-df634f57=""></span> <div id="help-needed" data-v-df634f57=""><span class="header-font" data-v-df634f57="">Hulp nodig</span><a id="help" href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/contact"><img class="question-menu-item" src="/assets/images/question-mark.svg" alt="?" data-v-df634f57=""></a></div> </div> <hr class="divider" data-v-df634f57=""> </div> <div class="navbar navbar-fixed-top"> <div class="navbar-inner"> <div class="container-fluid"> <a href="https://informatievlaanderen.github.io/VSDS-Tech-Docs/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Home</span> </button> </a> <a href="https://github.com/Informatievlaanderen/VSDS-Onboarding-Example"> <button type="button" class="btn btn-navbar custom-border-activated" > <span class="nav-icon-bar">Tutorial</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Linked Data Interactions</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-LDESServer4J/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES server</span> </button> </a> <a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/ldio/ldio-inputs/ldio-ldes-client"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">LDES client</span> </button> </a> <a href="https://www.vlaanderen.be/vlaamse-smart-data-space-portaal/blog"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">Blog posts</span> </button> </a> <a href="https://informatievlaanderen.github.io/OSLO-mapping/"> <button type="button" class="btn btn-navbar custom-border" > <span class="nav-icon-bar">OSLO mapping</span> </button> </a> </div> </div> </div> <style> #help-needed[data-v-df634f57] { display: flex; align-items: center; gap: 5px; background-image: url(https://informatievlaanderen.github.io/OSLO-mapping/assets/images/hulp_nodig.svg); width: 144px; height: 44px; } .custom-border-activated { background-color: rgb(255, 230, 21); } .custom-border { border: 0.3px solid rgb(0, 200, 171); /* Randkleur */ /* Voeg hier eventueel andere stijlelementen toe */ } .navbar-fixed-top .navbar-inner { margin-top:30px; height: 35px; padding: 0; border-top: 1px solid #d4d4d4; z-index: 1000; position: fixed; right:0px; } @media (min-width: 50rem) .navbar-fixed-top { position: relative !important; width: auto !important; height: 100% !important; padding: 0; transition: none; } .global-header[data-v-df634f57] { display: flex; margin-left: 0px; align-items: center; position: fixed; width: 100%; background-color: white; z-index: 100; } .test-header{ margin-bottom: 20px; overflow:hidden; z-index: 100; } element.style { } .small-global-header-divider[data-v-df634f57] { margin: 0 8px 0 4px; } .header-font { color: #333332; font-family: Flanders Art Sans, sans-serif; font-size: 12px; font-style: normal; font-weight: 500; line-height: normal; letter-spacing: 0.5px; text-transform: uppercase; } .spacer { flex-grow: 1; } .divider { border: 1px solid #8f8f8f66; margin: 0; } #help-needed > span[data-v-df634f57] { margin-left: 25px; } /* title of the site */ #header { height: 80px; } #header hgroup { position: absolute; top: 10px; left: 20px; } #header h1 { margin: 0; font-size: 1.75em; font-weight: bold; } #header h2 { color: #ccc; margin: 0 0 4px 16px; line-height: 0.8; font-size: 1.0em; font-weight: normal; } #header a, #header a:hover, #header a:visited { text-decoration: none; } .navbar .nav > .active > a, .navbar .nav > .active > a:hover, .navbar .nav > .active > a:focus { box-shadow: none; } .navbar .btn-navbar { margin-bottom: 5px; } </style> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Onboarding tutorial </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Onboarding tutorial</a></li></ul> <div class="nav-category">Publishing an LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/publishing/publishing_protected_LDES" class="nav-list-link">Publishing a protected LDES</a></li><li class="nav-list-item"><a href="/publishing/basic_setup" class="nav-list-link">Basic setup</a></li><li class="nav-list-item"><a href="/publishing/minimal_server" class="nav-list-link">Minimal Server</a></li></ul> <div class="nav-category">Data pipeline</div> <ul class="nav-list"><li class="nav-list-item active"><a href="/pipeline/minimal_workbench" class="nav-list-link active">Minimal workbench</a></li><li class="nav-list-item"><a href="/pipeline/advanced_conversion" class="nav-list-link">Advanced conversion</a></li></ul> <div class="nav-category">Consuming an LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/consuming/consuming" class="nav-list-link">Setup a minimal LDES client</a></li></ul> <div class="nav-category">Protected LDES</div> <ul class="nav-list"><li class="nav-list-item"><a href="/protected/publishing_protected_LDES" class="nav-list-link">Publishing a protected LDES</a></li></ul> </nav> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Onboarding tutorial" aria-label="Search Onboarding tutorial" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="setting-up-a-minimal-ldio-workbench"> <a href="#setting-up-a-minimal-ldio-workbench" class="anchor-heading" aria-labelledby="setting-up-a-minimal-ldio-workbench"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Setting Up a Minimal LDIO Workbench </h1> <p>This quick start guide will show you how to setup a minimal workbench to create version objects from state objects.</p> <p>Please see the <a href="../README.md">introduction</a> for the example data set and pre-requisites, as well as an overview of all examples.</p> <h2 id="show-me-your-workbench"> <a href="#show-me-your-workbench" class="anchor-heading" aria-labelledby="show-me-your-workbench"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Show Me Your Workbench </h2> <p>The LDES Server allows to ingest version objects but typically the source data represents the state of an object and not a version in time of this state. That is why a data transformation is needed to create such a version object.</p> <p>Such a data transformation can be standalone or as part of a data transformation pipeline which can be build in various ways with many different data processing systems.</p> <p>One such a workbench that allows to create data pipelines is <a href="https://nifi.apache.org/">Apache NiFi</a>. This is a mature and solid open-source solution that comes with many features, allows for horizontal scaling and comes with many standard processors for creating and monitoring complex data pipelines. However, it also comes with a steep learning curve and some other drawbacks.</p> <p>The Linked Data Interactions Orchestrator (<a href="https://informatievlaanderen.github.io/VSDS-Linked-Data-Interactions/">LDIO</a> is a simple and more light-weight solution that eases the process of creating more straightforward, linear data transformations while requiring minimal resources and attempting to keep the learning curve as low as possible. It is by no means a silver bullet but experience has learned us that most data publishing use cases can easy be covered with a simple linear pipeline and as such LDIO usually suffies.</p> <p>LDIO allows to create one or more synchronous linear pipelines that convert linked and non-linked data to version objects that can be ingested by an LDES Server. It is centered around the concept of one input source with an adaptor to convert to linked data, one or more in-memory transformation steps and sending the result to one or more output sinks.</p> <p>Various input components are available for starting a pipeline such as: accepting HTTP messages both using a push model (HTTP listener) and a pull model (HTTP poller), reading from Kafka, etc.</p> <p>If the source data is already linked data you can use a simple RDF adaptor which allows to parse various RDF serializations. If the source data is not yet linked data you can use either a JSON-LD adaptor to attach a JSON-LD context to a JSON message or alternatively a RML adaptor, which allows to create linked data from various other message formats, such as JSON, XML, CSV, etc.</p> <p>On the output side we also provide several possibilities such as POST-ing using HTTP, writing to Kafka, etc.</p> <p>We provide several transformation components for manipulating linked data but most data transformations can be done using a SPARQL construct transformation step. In addition, we also provide some components for more specific tasks such as enriching the data from some external HTTP source, converting GeoJson to Well Known Text (WKT), etc.</p> <p>All these components are provided as part of the LDIO workbench which is packaged as a Docker image. The Docker images are available on <a href="https://hub.docker.com/r/ldes/ldi-orchestrator">Docker Hub</a>. The stable releases can be found <a href="https://hub.docker.com/r/ldes/ldi-orchestrator/tags">here</a>.</p> <h2 id="configure-your-first-pipeline"> <a href="#configure-your-first-pipeline" class="anchor-heading" aria-labelledby="configure-your-first-pipeline"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Configure Your First Pipeline </h2> <p>The example <a href="./docker-compose.yml">docker compose file</a> only contains a LDIO service which runs in a private network and uses volume mapping to have its configuration file available in the container. As we will see in a minute, the pipeline starts with a HTTP listener and therefore we need a port mapping to allow the workbench to receive HTTP messages.</p> <p>The <a href="./config/application.yml">workbench configuration file</a> starts with specifying the port on which the HTTP listener will accept requests. We have used the default port number 8080 and could have easily omitted it from te configuration. Other than that, we only need to specify the actual pipeline definition.</p> <blockquote> <p><strong>Note</strong> that the workbench can contain more than one pipeline if needed.</p> </blockquote> <p>The pipeline definition starts with a name and a description. The latter is purely for documentation purposes, but the former is used as the base path on which the HTTP listener receives requests. In our case this is (based on the docker compose port mapping): http://localhost:9004/p+r-pipeline. After that the definition continues with the input component and associated adapter, the transformation steps and the output(s). Let’s look at these in more detail.</p> <p>The input component simply states that it is a HTTP listener which uses a RDF adaptor and as such is expecting Linked Data:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">input</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">be.vlaanderen.informatievlaanderen.ldes.ldio.LdioHttpIn</span>
  <span class="na">adapter</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">be.vlaanderen.informatievlaanderen.ldes.ldi.RdfAdapter</span>
</code></pre></div></div> <p>We need a transformation step to turn the linked data state object which we receive into a version object. We need to specify for which object type we need to change it to a version object. We use this type to retrieve that object’s identifier and create the version object ID based on this identifier concatenated with the delimiter and the value of the <code class="language-plaintext highlighter-rouge">date-observed-property</code>. We also use the identifier to add a property as specified by <code class="language-plaintext highlighter-rouge">versionOf-property</code> to the version object. Finally, we also use the <code class="language-plaintext highlighter-rouge">date-observed-property</code> value to add a property as defined by the <code class="language-plaintext highlighter-rouge">generatedAt-property</code> to the version object. This sounds way more complicated than it actually is as we will show later.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">transformers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">be.vlaanderen.informatievlaanderen.ldes.ldi.VersionObjectCreator</span>
    <span class="na">config</span><span class="pi">:</span>
      <span class="na">member-type</span><span class="pi">:</span> <span class="s">https://example.org/ns/mobility#offStreetParkingGround</span>
      <span class="na">delimiter</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/"</span>
      <span class="na">date-observed-property</span><span class="pi">:</span> <span class="s">&lt;http://www.w3.org/ns/prov#generatedAtTime&gt;</span>
      <span class="na">generatedAt-property</span><span class="pi">:</span> <span class="s">http://www.w3.org/ns/prov#generatedAtTime</span>
      <span class="na">versionOf-property</span><span class="pi">:</span> <span class="s">http://purl.org/dc/terms/isVersionOf</span>
</code></pre></div></div> <blockquote> <p><strong>Note</strong> that we used the <code class="language-plaintext highlighter-rouge">http://www.w3.org/ns/prov#generatedAtTime</code> property for both creating the version object ID as well as for the <code class="language-plaintext highlighter-rouge">generatedAt-property</code>. This will prevent creating another property with the same date/time value.</p> </blockquote> <p>Finally, the version object is output to the specified sink. For demo purposes we use a component that simply logs the member to the console, which for a Docker container results in its logs.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">outputs</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">be.vlaanderen.informatievlaanderen.ldes.ldio.LdioConsoleOut</span> 
</code></pre></div></div> <h2 id="launch-the-magic"> <a href="#launch-the-magic" class="anchor-heading" aria-labelledby="launch-the-magic"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Launch the Magic </h2> <p>After this long introduction let’s get our hands dirty and see the magic in action.</p> <p>To start the workbench and wait until it is available:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
<span class="k">while</span> <span class="o">!</span> docker logs <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldio-workbench$"</span><span class="si">)</span> 2&gt; /dev/null | <span class="nb">grep</span> <span class="s1">'Started Application in'</span> <span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div> <p>There is no visual component yet for the LDIO workbench, but you can check its status at http://localhost:9004/actuator/health.</p> <h2 id="youve-got-mail"> <a href="#youve-got-mail" class="anchor-heading" aria-labelledby="youve-got-mail"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> You’ve Got Mail </h2> <p>Now that the workbench is up and running we can send a <a href="./data/message.jsonld">message</a> through the pipeline and see its version object outputted to the workbench logs. We use the following simple JSON-LD message (clipped to the relevant parts):</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"@context"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"@vocab"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://example.org/ns/mobility#"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"urllinkaddress"</span><span class="p">:</span><span class="w"> </span><span class="s2">"@id"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"@type"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"lastupdate"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"@id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://www.w3.org/ns/prov#generatedAtTime"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://www.w3.org/2001/XMLSchema#dateTime"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"lastupdate"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2023-11-30T21:45:15+01:00"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"offStreetParkingGround"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"urllinkaddress"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal"</span><span class="p">,</span><span class="w">
    </span><span class="err">...</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <blockquote> <p><strong>Note</strong>: do not worry if you do not understand every detail in the context part. Its main purpose is to add meaning to the state object properties.</p> </blockquote> <p>To send the message into the pipeline:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s2">"Content-Type: application/ld+json"</span> <span class="s2">"http://localhost:9004/p+r-pipeline"</span> <span class="nt">-d</span> <span class="s2">"@./data/message.jsonld"</span>
</code></pre></div></div> <p>Since it is a small and straight forward message the workbench log will almost immediately contain the version object.</p> <p>To watch the version object appear in the workbench log</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs <span class="nt">-n</span> 30 <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"name=ldio-workbench$"</span><span class="si">)</span>
</code></pre></div></div> <p>You should see the following (clipped to the relevant parts):</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@prefix mobility:         &lt;https://example.org/ns/mobility#&gt; .
@prefix park-and-ride-pr: &lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/&gt; .
@prefix prov:             &lt;http://www.w3.org/ns/prov#&gt; .
@prefix rdf:              &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix terms:            &lt;http://purl.org/dc/terms/&gt; .

&lt;https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00&gt;
        rdf:type                      mobility:offStreetParkingGround ;
        terms:isVersionOf             park-and-ride-pr:pr-gentbrugge-arsenaal ;
        prov:generatedAtTime          "2023-11-30T21:45:15+01:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; ;
...
</code></pre></div></div> <p>If you compare the generated member in the container log with the example that we process, you will notice that the state object ID (<code class="language-plaintext highlighter-rouge">park-and-ride-pr:pr-gentbrugge-arsenaal</code> or <code class="language-plaintext highlighter-rouge">http://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal</code> in full) is a property (<code class="language-plaintext highlighter-rouge">terms:isVersionOf</code> or <code class="language-plaintext highlighter-rouge">http://purl.org/dc/terms/isVersionOf</code> in full) of the version object and the version ID (<code class="language-plaintext highlighter-rouge">https://stad.gent/nl/mobiliteit-openbare-werken/parkeren/park-and-ride-pr/pr-gentbrugge-arsenaal/2023-11-30T21:45:15+01:00</code>) is a combination of that state object ID, the delimiter (<code class="language-plaintext highlighter-rouge">/</code>) and the <code class="language-plaintext highlighter-rouge">prov:generatedAtTime</code> property (<code class="language-plaintext highlighter-rouge">2023-11-30T21:45:15+01:00</code>).</p> <h2 id="thats-all-folks"> <a href="#thats-all-folks" class="anchor-heading" aria-labelledby="thats-all-folks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> That’s All Folks </h2> <p>You now know how to configure a basic LDIO workbench which takes in RDF messages containing a single state object and turn it into a version object that can be ingested as a LDES member.</p> <p>To bring the containers down and remove the private network:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose down
</code></pre></div></div> </main> <hr> <footer> <p class="text-small text-grey-dk-100 mb-0"></p> <div class="d-flex mt-2"> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
